\documentclass[12pt]{article}
\usepackage[usenames]{color} %used for font color
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{bytefield}
\usepackage{amssymb} %maths
\usepackage{amsmath} %maths
\usepackage[utf8]{inputenc} %useful to type directly accentuated characters

% PDF Bookmarks and hyperref stuff
\usepackage[
  bookmarks=true,
  bookmarksnumbered=true,
  colorlinks=true,
  filecolor=blue,
  linkcolor=blue,
  urlcolor=blue,
  hyperfootnotes=true
]{hyperref}

% the following command sets a 1-inch left margin.
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

% set width of the text - what is left will be the right
% margin; in this case, right margin is
% 8.5in - 1in - 6.5in = 1in.
\setlength{\textwidth}{6.5in}

% set top margin "extras" to 0 to get a 1 inch usable margin
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}

% set text length to 9 inches
\setlength{\textheight}{9in}

\author{David MacMahon}
\title{VLBI Phased Array \\ iBob and BEE2 \\ Programmer's Guide}

\begin{document}
\maketitle
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newlength{\itemseporig}
\setlength{\itemseporig}{\itemsep}

% Put new commands here
\newcommand{\tighten}{
  \setlength{\itemsep}{-\parskip}
}
\newcommand{\loosen}{
  \setlength{\itemsep}{\itemseporig}
}
\newcommand{\LSB}{least significant byte }
\newcommand{\LSn}{least significant nybble }
\newcommand{\LSb}{least significant bit }
\newcommand{\LSns}{least significant nybbles }
\newcommand{\LSbs}{least significant bits }
\newcommand{\MSb}{most significant bit }
\newcommand{\MSbs}{most significant bits }
\newcommand{\MSB}{most significant byte }
\newcommand{\devitem}[2]{\item[#1] [#2] \\ }
\newcommand{\rwreg}[1]{\devitem{#1}{R/W register}}
\newcommand{\rwregn}[1]{\item[#1] {} \tighten} % For "stacked" rwregs
\newcommand{\rwregs}[1]{\devitem{#1}{R/W registers} \loosen} % Ends stacked rwregs
\newcommand{\roreg}[1]{\devitem{#1}{R register}}
\newcommand{\roregn}[1]{\item[#1] {} \tighten} % For "stacked" roregs
\newcommand{\roregs}[1]{\devitem{#1}{R registers} \loosen} % Ends stacked roregs
\newcommand{\bram}[1]{\devitem{#1}{Block RAM}}
\newcommand{\bramn}[1]{\item[#1] {} \tighten} % For "stacked" brams
\newcommand{\brams}[1]{\devitem{#1}{Block RAM} \loosen} % Ends stacked brams
\newcommand{\degree}[1]{$#1^{\circ}$}
\newcommand{\e}[1]{\ensuremath{\times 10^{#1}}}

\begin{abstract}
Describes the registers and devices in the various iBob and BEE2 designs used
in the VLBI phased array processor for CARMA and SMA.
\end{abstract}

\section{Gateware Versions}

The history of the gateware designs has two major epochs: real and complex.
The real epoch covers the original designs, which processed the signal as real
(i.e. non-complex) data.  Due to limitations in dealing with real data, namely
lack of phase information and control, the gateware designs were modified to
convert the real signal into complex form.  These designs dealing with complex
data comprise the complex epoch.

Within each epoch, registers and devices have been added, removed, and renamed.
Instead of attempting to describe all revisions of the gateware, this document
only describes specific versions of the gateware as noted in each section.  The
complete history for the various designs are in a Git repository.  The official
Git repository is only available via (non-public) ssh using this URL:

\begin{center}
\nolinkurl{git@vlbi-devel.cfa.harvard.edu:phringes.git}
\end{center}

A publicly visible mirror is available using this URL:

\begin{center}
\url{http://astro.berkeley.edu/~davidm/phringes.git}
\end{center}

\section{ibob\_phased\_array\_2k}

This section documents the ibob\_phased\_array\_2k\_2011\_Feb\_23\_0158 design.

In addition to synchronizing internal timing signals with external timing
signals.  The ibob\_phased\_array\_2k design has a few critical registers that
must be set to non-zero values for proper operation.  These registers are
briefly listed here; full details are provided below.

\begin{description}
\rwreg{start\_xaui} Must be 1 to enable XAUI transmission as well as the clock
output for the BEE2 calibration correlator.
\rwregs{gain0 - gain3} At least one gain register must be non-zero to get
non-zero output through to the DBE.
\end{description}

  \subsection{Synchronization}

Different observatories use different synchronization and phase switching
schemes.  The ibob\_phased\_array\_2k design accommodates the schemes used at
SMA and CARMA.  Additionally, the design requires an external 1~PPS pulse with
which it synchronizes internally generated sync signals used with downstream
systems.

SMA phase switching is based on a Heartbeat (HB) signal with frequency
$\frac{52 \, \mathrm{MHz}}{2^{19}} \approx 99.182 \, \mathrm{Hz}$.  This signal
is generated on board from the 256 MHz FPGA clock and is synchronized with the
external SMA Start of Walsh Frame (SOWF) signal using the \verb|armsowf|
command.  An internal SOWF signal is also generated on board synchronized with
the external SOWF signal.  The frequency of SOWF is $\frac{52 \,
\mathrm{MHz}}{2^{25}} \approx 1.550 \, \mathrm{Hz}$.

CARMA phase switching is based on a 1024~PPS signal.  This signal is generated
on board from the 256~MHz FPGA clock and is synchronized with the external
1~PPS signal using the \verb|arm1pps| command.  An internal 1~PPS signal is
also generated on board synchronized with the external 1~PPS.

The design also uses the internally generated 1024~PPS and 1~PPS signals for
other purposes (e.g. XAUI synchronization and synchronous noise source seeding)
independent of the phase switching scheme being used, so the external 1~PPS
must always be supplied and the internal 1~PPS must always be synchronized to
it via the \verb|arm1pps| command.

\begin{description}
\filbreak
\rwreg{ppssel} Selects the ADC sync pulse to which the internally generated
1~PPS signal will be synchronized.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Select ADC0 sync signal (typically for CARMA)
\item[1] Select ADC1 sync signal (typically for SMA)
\end{description}

\roreg{onepps\_sync/diff} This register captures the difference, in FPGA clock
cycles, between the external 1~PPS signal and the internally generated 1~PPS
signal.  Normally this register will read 0, but since the external 1~PPS
signal is not synchronous with the ADC sample clock, values of 1 or
256,000,000 are also acceptable.  Other values indicate a problem.

\roreg{onepps\_sync/ext\_cnt} This register contains the number of rising edges
seen on the external 1~PPS signal since the last re-arming of the internal
1~PPS signal.

\roreg{onepps\_sync/ext\_period} This register contains the number of FPGA clock
cycles between the two most recent rising edges seen on the external 1~PPS
signal.  It should read 256,000,000 $\pm$ 1.

\rwreg{onepps\_sync/arm1pps} A 0 to 1 transition of bit~0 of this register will
arm the internal 1~PPS generator to re-synchronize with the next rising edge of
the selected sync pulse.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\roreg{onepps\_sync/arm1pps\_ack} A 1 to 0 transition of bit~0 of
\verb|onepps_sync/arm1pps| clears (i.e. sets to zero) this register.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ack}}
\end{bytefield}

Bit~0 of this register is set to 1 on the rising edge of the next sync pulse
that re-synchronizes the internal 1~PPS generator.  This can be used to verify
that the internal 1~PPS generator did indeed re-synchronize after being armed.
This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\filbreak
\rwreg{sowfsel} Selects the source of the external SOWF signal to which the
internally generated SOWF signal will be synchronized.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Select GPIO 0 bit index 8 (aka J6 pin 17)
\item[1] Select ADC0 sync signal
\end{description}

\roreg{hb\_sync/diff} This register captures the difference, in FPGA clock
cycles, between the external SOWF signal and the internally generated SOWF
signal.  Normally this register will read 0, but since the external SOWF period
is not commensurate with the ADC clock period, values of 1 or 165,191,049 (plus
or minus a few clock cycles) are also acceptable.  Other values indicate a
problem.

\roreg{hb\_sync/ext\_cnt} This register contains the number of rising edges
seen on the external SOWF signal since the last re-arming of the internal SOWF
signal.

\roreg{hb\_sync/ext\_period} This register contains the number of FPGA clock
cycles between the two most recent rising edges seen on the external SOWF
signal.  It should read 165,191,049 $\pm$ 2.

\rwreg{hb\_sync/arm\_sowf} A 0 to 1 transition of bit~0 of this register will
arm the internal HB and SOWF generators to re-synchronize with the next rising
edge of the external SOWF signal.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

This register is not often used directly since (re-)arming is normally done via
the \verb|armsowf| command.

\roreg{hb\_sync/armsowf\_ack} A 1 to 0 transition of bit~0 of
\verb|hb_sync/arm\_sowf| clears (i.e. sets to zero) this register.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ack}}
\end{bytefield}

This register is set to 1 on the next rising edge of the external SOWF signal.
This can be used to verify that the internal HB and SOWF generators did indeed
re-synchronize after being armed.  This register is not often used directly
since (re-)arming is normally done via the \verb|armsowf| command.

\roreg{uptime} The uptime register is a 32~bit counter that counts seconds
since the FPGA started running.  It cannot be reset (other than reprogramming
the FPGA) and is not synchronized with any other 1 PPS source.

\end{description}

  \subsection{Input Selection}

\begin{description}

\rwreg{insel}  Input selection.  Uses two bits per time sample (i.e. demux
path) per input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{2}{\scriptsize in3 \\ t3} &
  \bitbox{2}{\scriptsize in3 \\ t2} &
  \bitbox{2}{\scriptsize in3 \\ t1} &
  \bitbox{2}{\scriptsize in3 \\ t0} &
  \bitbox{2}{\scriptsize in2 \\ t3} &
  \bitbox{2}{\scriptsize in2 \\ t2} &
  \bitbox{2}{\scriptsize in2 \\ t1} &
  \bitbox{2}{\scriptsize in2 \\ t0} &
  \bitbox{2}{\scriptsize in1 \\ t3} &
  \bitbox{2}{\scriptsize in1 \\ t2} &
  \bitbox{2}{\scriptsize in1 \\ t1} &
  \bitbox{2}{\scriptsize in1 \\ t0} &
  \bitbox{2}{\scriptsize in0 \\ t3} &
  \bitbox{2}{\scriptsize in0 \\ t2} &
  \bitbox{2}{\scriptsize in0 \\ t1} &
  \bitbox{2}{\scriptsize in0 \\ t0}
\end{bytefield}

\begin{description}
\item[0] Select ADC for one demux path of one input
\item[1] Select noise source for one demux path of one input
\item[2] Select constant 0 for one demux path of one input
\end{description}

Examples:
\begin{description}

\item[0x00000000] Select ADC for all demux paths of all inputs
\item[0x00000001] Select noise source for demux path 0 of input0, select ADC
                  for all other demux paths
\item[0x00000055] Seelct noise source for all demux paths of input 0, select
                  ADC for all other inputs \item[0x55555555] Select noise
                  source for all demux paths of all inputs
\item[0x55000000] Select noise source for all demux paths of input 3, select
                  ADC for all other inputs \item[0xA0000000] Select constant 0
                  for demux paths 2 and 3 of input 3, select ADC for all other
                  inputs
\end{description}
\end{description}

  \subsection{Noise Generators}

\begin{description}

\rwreg{noise/arm}  A 0 to 1 transition of bit~0 of each nybble arms that
input's noise generator.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{19}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in3}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in2}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in1}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in0}}
\end{bytefield}

The least significant nybble
corresponds to input0.  A value of 0x0011 will arm the noise generators for
input0 and input1.  A value of 0x1111 will arm all noise generators.

Once a noise generator is armed, it will re-seed starting on the next internal
1~PPS rising edge.  This can be used to synchronously seed noise generators
across multiple devices or within one device.

\filbreak
\rwregn{noise/seed/0}
\rwregn{noise/seed/1}
\rwregn{noise/seed/2}
\rwregs{noise/seed/3} Sets 32~bit seed for noise generators for corresponding
inputs.  Because the inputs are demultiplexed by 4, each noise generator
actually contains two noise generators that each output two independent
normally distributed values each.  The 32~bit seed is actually split into two
16~bits seeds to seed the two contained noise generators.  Using a seed whose
two halves are identical (i.e.\ a multiple of 65537) will result in a signal
that has a lag-2 correlation coefficient of 1 resulting in a non-flat spectrum.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{16}{seed high} &
  \bitbox{16}{seed low}
\end{bytefield}

\end{description}

  \subsection{Delay Core}

The Delay Core consists of a coarse delay (in units of FPGA clock cycles), a
fine delay (in units of ADC sample clock cycles), and a sub-sample delay (in
units of 1/16 an ADC sample clock cycle).  The sub-sample delay is implemented
using a quadrature fractional delay FIR filter that not only does sub sample
delay, but also converts the signal to complex form.  Converting to complex
form involves mixing by a local oscillator at $\pm F_s/4$.  The sign of the LO
frequency is user selectable and determines whether the Delay Core's complex
output will consist of the positive or negative frequencies of the real input.
Selecting the negative frequencies will result in a frequency reversal and
conjugation relative the positive frequencies.  See the \verb|sbsel| register
for more details.

\begin{description}

\rwregn{delay0}
\rwregn{delay1}
\rwregn{delay2}
\rwregs{delay3} The 17 \LSbs of these registers specify the overall delay to be
applied to by each input's Delay Core.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{15}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{17}{delay}
\end{bytefield}

The value written into these registers can be computed as

\begin{align*}
register\_value &= 16 \cdot adc\_sample\_delay + 64 &(\mathrm{mod}\:2^{17}) \\
                &= \mathrm{round}(16.384 \cdot ns\_delay) + 64 &(\mathrm{mod}\:2^{17})
\end{align*}

\filbreak
For example, to obtain a delay of 123.456~ns, the value to use would be
computed as

\begin{align*}
register\_value &= \mathrm{round}(16.384 \cdot 123.456) + 64 &(\mathrm{mod}\:2^{17}) \\
                &= 2087
\end{align*}

Because of the 64 sample offset and modulo $2^{17}$ behavior, minimum delay is
obtained with a value of 64, while maximum delay is obtained with a value of
63.

\rwreg{sbsel} The \verb|sbsel| (sideband select) register specifies whether the
complex output will consist of the positive or negative frequencies of the real
input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{16}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb3}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb2}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb1}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb0}}
\end{bytefield}

Each of the four \LSns (i.e. hex digits) of \verb|sbsel| corresponds
one input.  The \LSn specifies the sideband selection for input 0.  A value of
0 selects the positive frequencies; a value of 1 selects the negative
frequencies.  Writing 0x0100 will select positive frequencies for inputs~0,1,3
and negative frequencies for input2.

\end{description}

  \subsection{Phase Rotation}

After the Delay Core's conversion to complex, the signal passes through a phase
rotator.  The amount of phase rotation applied is a combination of the phase
offset introduced by fine delay, the phase value specified in the input's
\verb|phaseN| register, and the 0/90/180/270 degree phase switching specified
by the input's current phase switching state.  The phase offset introduced by
fine delay is automatically compensated; no user input is required.  The
\verb|phaseN| registers are described here and the phase switching states are
described in a separate subsection.

\begin{description}

\rwregn{phase0}
\rwregn{phase1}
\rwregn{phase2}
\rwregs{phase3} These registers specify the amount of user-specified phase
rotation to be applied to each input's complex signal.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{20}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{12}{phase}
\end{bytefield}

Because only the 12 least significant bits of these registers are used for one
complete turn in phase, the resolution is $\frac{2 \pi}{2^{12}}$ radians per
step or $\frac{360}{2^{12}}$ degrees per step (i.e. approximately 88
millidegrees per step).

The value written into these registers can be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(
                      phase\_radians \cdot \frac{2^{12}}{2 \pi}
                    \right) \\
                &   \:\text{or} \\
register\_value &=  \mathrm{round}\left(
                      phase\_degrees \cdot \frac{2^{12}}{360}
                    \right)
\end{align*}

For example, to phase
rotate a given input by 30 degrees, the value to use would be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(30 \cdot \frac{2^{12}}{360}\right) \\
                &=  341
\end{align*}

\end{description}

  \subsection{Phase Switching}

As mentioned elsewhere, the design supports both SMA and CARMA phase switching
schemes.  Both observatories use nested Walsh functions whereby the 180 degree
phase switching cycle completes once per 90 degree phase switching state.  The
Wash functions themselves are stored in two shared block RAM lookup tables.
One table is for the 180 degree phase switch cycle and the other table is for
the 90 degree phase switching cycle.  Each entry (i.e. row) in a Walsh table is
32 bits wide.  Each bit (i.e. column) corresponds to a given Walsh function.
Each input uses a user specified column for both the 90 and 180 degree Walsh
functions.  To provide the simplest and most versatile interface, the Walsh
tables are stored in unrolled form.

\begin{description}

\rwreg {walsh/syncsel} This register is used to select the timing of the Walsh functions.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

A value of 0 selects the internal 1024~PPS (for CARMA).  A value of 1 selects
the internal HB signal (for SMA).

\filbreak
\rwreg{walsh/colsel} This register is used to specify which columns (i.e. bits)
of the Walsh tables to use for each input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox[ltb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in3 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in2 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in1 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in0 \\ colsel}
\end{bytefield}

Each input is controlled by one byte of this register.  Input~0 uses the \LSB
of this register.  Only the five \LSbs of each byte are used to select
columns~0 through 31.  Column~0 is the \MSb of the 32~bit Walsh table entries.

\bramn{walsh/table/90} \brams{walsh/table/180} These shared block RAMs must be
programmed with the unrolled Walsh tables.  Each table (i.e. BRAM) is 2048
entries long.  Each entry is 32~bit wide.  Each bit position corresponds to a
column of a Walsh table.  The \MSb of each 32-bit entry corresponds to column~0
of the (up to) 32~column Walsh table.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{1}{\rotatebox{90}{\scriptsize col0}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col1}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col2}} &
  \bitbox[blt]{3}{\dots} &
  \bitbox[bt]{8}{} &
  \bitbox[bt]{4}{\dots} &
  \bitbox[bt]{8}{} &
  \bitbox[brt]{3}{\dots} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col29}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col30}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col31}}
\end{bytefield}

Table \verb|walsh/table/90| is for the 90 degree phase switching states.\\
Table \verb|walsh/table/180| is for the 180 degree phase switching states.

The Walsh tables are addressed by a counter that increments every phase
switching state (i.e. every 1024~PPS for CARMA; every HB for SMA) and is reset
at the end of every Walsh function cycle (i.e.  every 1~PPS for CARMA and every
SOWF for SMA).  Only the first N entries need to be populated, where N is the
number of phase switching states per complete phase switching cycle (i.e. 1024
for CARMA, 64 for SMA).

\end{description}

  \subsection{2-Bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  The calibration correlator gets 2~bit data
(at the ADC sample rate) from all inputs.  The quantization to 2~bits is
controlled by user specified threshold values.  The 2~bit coding represents
four distinct values: -3, -1, +1, +3.

\begin{description}

\rwregn{quant/thresh0}
\rwregn{quant/thresh1}
\rwregn{quant/thresh2}
\rwregs{quant/thresh3}  These registers set the thresholding level used for
quantizing each input to 2~bits.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{25}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{7}{threshold}
\end{bytefield}

\filbreak
The quantized value for a given input value of $x$ and unsigned 7~bit threshold
value $thresh$ is determined according to the equations shown here.  Note that
the output value for a zero valued input alternates between -1 and +1.

\begin{align*}
           &\,x <= -thresh &\Rightarrow -3 \\
-thresh <  &\,x < 0        &\Rightarrow -1 \\
           &\,x = 0        &\Rightarrow \pm1 \\
      0 <  &\,x < thresh   &\Rightarrow +1 \\
 thresh <= &\,x            &\Rightarrow +3
\end{align*}

When using a digital noise source as an input, a threshold value of 16 results
in a $\left\{\frac{1}{6}, \frac{2}{6}, \frac{2}{6}, \frac{1}{6}\right\}$
distribution in the 2~bit quantized values.

\end{description}

  \subsection{8-bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  Before being sent to the DBE, the four
8~bit input signals are summed together then scaled and rounded back to 8~bits.
Before the sum each input signal is multiplied by a gain factor.  This gain
factor is intended to weight the inputs according to system temperature, but
thus far they have been used only to scale all inputs equally or to zero out an
input to exclude it from the sum.  The sum can be scaled by~$\frac{1}{2}$
or~$\frac{1}{4}$ (see the \verb|summer/shift| register) before rounding to
8~bits prevent to overflow.

\begin{description}

\rwregn{gain0}
\rwregn{gain1}
\rwregn{gain2}
\rwregs{gain3} These registers control the gain factor for each input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{24}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{8}{gain}
\end{bytefield}

Only the 8 \LSbs are used.  They are currently interpreted as an unsigned
number with 7 fractional bits.  Thus, the range of gain values that can be
applied to each input is~$0$ to~$1\frac{127}{128}$.

\filbreak
\rwreg{summer/shift} This register select the scaling factor applied to the sum
before re-quantizing to 8~bits.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

Set this to~0 to scale the sum by~$\frac{1}{2}$ (e.g. for independent noise
dominated inputs).  Set this to~1 to scale the sum by~$\frac{1}{4}$ (e.g. for
coherent inputs).

\end{description}

  \subsection{XAUI}

The sum of the phased inputs is sent to the DBE via the XAUI0 connector.  The
2-bit quantized inputs are sent to the calibration correlator via the XAUI1
connector.  XAUI data transmission is \emph{dis}abled by default and must be
explicitly enabled via software (see below).

\begin{description}

\rwreg{start\_xaui} This register controls transmission over the XAUI links.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize stx}}
\end{bytefield}

Writing a 1 to this register enables a divide-by-2 counter that drives the BEE2
calibration correlator's \verb|usr2_clk| input and the two XAUI links' data
valid inputs (data is de-muxed by two for XAUI transmission) thereby enabling
transmission over the XAUI links.

Writing a 0 (the default) disables, and holds in reset, the divide-by-two
counter that drives the BEE2 calibration correlator's \verb|usr2_clk| input and
the two XAUI links' data valid inputs (data is de-muxed by two for XAUI
transmission).

\roregn{xaui\_0/rx\_linkdown}
\roregs{xaui\_1/rx\_linkdown} A value of 1 indicates a ``link down'' status on
the (unused) receive side of the indicated XAUI connection, which strongly
implies a similar status for its transmit side.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ldn}}
\end{bytefield}

\end{description}

  \subsection{Front Panel SMA Output}

\begin{description}

\rwreg{smasel} Selects which signal to output over the front panel \verb|SMA0|
connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}

\item[0] Outputs a 128~MHz square wave (50\% duty cycle) if XAUI output is
enabled (i.e. register \verb|start_xaui| is 1), otherwise a constant 0.

\item[1] Outputs a constant 0.

\end{description}

\filbreak
\rwreg{monsel} Selects which signal to output over the front panel \verb|SMA1|
connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{3}{sel}
\end{bytefield}

\begin{description}

\item[0] Outputs a constant 0.

\item[1] Outputs the internal 1024~PPS signal.

\item[2] Outputs the internal Heartbeat (HB) signal.

\item[3] Outputs the internal Start of Walsh Frame (SOWF) signal.

\item[4] Outputs the internal 1~PPS signal.

\item[5] Outputs the sampled sync0 signal (from ADC0)

\item[6] Outputs the sampled sync1 signal (from ADC1)

\end{description}

\end{description}

\filbreak
  \subsection{Front Panel LEDs}
\begin{description}
\item[LED0] Not used.
\item[LED1] Not used.
\item[LED2] Briefly blinks on each rising edge of the sync0 input.
\item[LED3] Not used.
\item[LED4] Not used.
\item[LED5] Not used.
\item[LED6] Not used.
\item[LED7] Not used.
\item[LED8] Indicates FPGA is configured (non-functional on some iBobs).
\end{description}

\newpage
\section{bee2\_complex\_corr}

This section documents the bee2\_complex\_corr\_floating\_2011\_Feb\_17\_2045
design.

The bee2\_complex\_corr design receives 2+2 bit samples (i.e. 2 real bits and 2
imaginary bits per sample) from a total of eight inputs (two IPAs).  It cross
correlates one of these signals (user selectable) with itself and the other
seven inputs.  Each of the 7 cross-correlations and 1 auto-correlation consists
of 16 lags (-8 to +7).  In addition to the data samples, the design also
receives sync and 90 degree phase state information from the IPAs over the XAUI
links' out of band channel.  This allows the correlator to perform sideband
separation, producing both upper and lower sideband lag spectra for each
baseline.

\subsection{Input numbering}

The four signals arriving over XAUI1 are considered to be input0 through
input3.  The four signals arriving over XAUI0 are considered to be input4
through input7.  Note that the higher number XAUI port contains the lower
number inputs and vice versa.

\subsection{Input values}

The four distinct values of the 2~bit samples represent signal values of -3,
-1, +1, and +3.  The threshold registers in the ibob\_phased\_array\_2k design
should be set such that approximately 1/6 of the samples are -3, 1/3 are -1,
1/3 are +1, and 1/6 are +3.  With this distribution, the lag~0 auto-correlation
will have a mean of 11/3 and a variance of 128/9.

\subsection{Integration limit}

With an input signal distribution as described above, a one second (i.e.
1024\e6 samples) integration will have a mean of $\frac{11}{3}\cdot1024\e6$ and
a variance of $\frac{128}{8}\cdot1024\e6$.  This integrated mean is more
3.75\e9, which is well over 2.1475\e9, the maximum value supported by a signed
32-bit value.  To delay overflowing, the BRAM vector accumulators are 36 bits
wide.  Their output values are rounded to 32 bits wide before writing them into
shared BRAMs.

Another factor of 2 savings is obtained by dropping the LSB of the
sub-integrations.  The input values are all odd so their products will all be
odd too.  Since an even number of odd products are integrated before the BRAM
vector accumulators, the \LSb will always be 0, so it is dropped without any
loss of precision.

These two techniques result in scaling down the integrations by a factor of 32.
This allows integrations as long as 18 seconds without overflowing the 36 bit
vector accumulators (or the 32 bit shared BRAMs).  This limit is only for
highly correlated signals such as the lag~0 auto-correlation or coherent noise
sources.  Inputs dominated by independent noise (e.g. astronomical cross
correlations) have far higher maximum integration times.

\subsection{XAUI alignment and monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
correlation.  The design will automatically align the two XAUI streams and, if
ever necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize del}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize mon}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize cor}}
\end{bytefield}

Setting bit~0 (cor) to 1 will reset the XAUI core itself (rarely needed).
Setting bit~1 (mon) to 1 will reset the counters associated with XAUI
monitoring.  Setting bit~2 (del) to 1 will reset the registers that capture the
relative delays of the two XAUI links.  These bits are level sensitive, not
edge sensitive, so they must be cleared to take the associated circuitry out of
reset.

\roregn{xaui0/linkdown\_cnt}
\roregs{xaui1/linkdown\_cnt} Indicates how many times the link has gone down
(i.e. transitioned from up to down).  Under normal operations this register
should read~0, though it may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period}
\roregs{xaui1/period}
Indicates the number of FPGA (256 MHz) clock cycles between the most recently
received 1024~PPS pulse and the previous one.  Under normal operations, this
register should read~250000.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period\_err}
\roregn{xaui1/period\_err}
\roregn{xaui0/period\_err\_cnt}
\roregs{xaui1/period\_err\_cnt}
The XAUI monitoring logic constantly monitors the number of FPGA cycles between
1024~PPS pulses.  It counts the number of period errors and remembers the most
recent erroneous period value.  The \verb|xauiN/period_err_cnt| registers
indicate the total number of erroneous periods detected.  Under normal
operations, these registers should read~0.  The \verb|xauiN/period_err|
registers indicate the most recent erroneous period value.  Under normal
operations, these registers should read~0 (i.e. no erroneous period measured).
These registers are reset by bit~1 of the \verb|xaui_rst| register.

\filbreak
\roregn{xaui0/sync\_cnt}
\roregs{xaui1/sync\_cnt} This register indicates the total number of 1024~PPS
pulses received.  Since it is a 32~bit counter, it will roll over approximately
every 48.5 days.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/rx\_empty\_cnt}
\roregs{xaui1/rx\_empty\_cnt} Indicates how many times the XAUI FIFO has
underflowed.  Under normal operations this register should read~0, though it
may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/almost\_full}
\roregs{xaui1/almost\_full} Indicates the current state of the XAUI's
\verb|almost_full| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize af}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/rx\_linkdown}
\roregs{xaui1/rx\_linkdown} Indicates the current state of the XAUI's
\verb|link_down| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ldn}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/valid}
\roregs{xaui1/valid} The two \LSbs of this register contain the current and
previous value of the XAUI block's \verb|valid| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize val}
\end{bytefield}

Since this status bit should toggle every clock cycle, this register should
read~1 or~2 under normal operation.

\filbreak
\roregn{xaui\_aligner/delay0}
\roregs{xaui\_aligner/delay1} These registers indicate the number of cycles
from the stream's incoming 1024~PPS and the reference 1024~PPS.  Since the
reference 1024~PPS is just a 32 cycle delayed version of XAUI0's 1024~PPS,
\verb|xaui_aligner/delay0| should always read 32.  Under normal operations,
\verb|xaui_aligner/delay1| should be $32\pm32$, but usually it will be
$32\pm4$.
\end{description}

\subsection{Synchronization and Integration}

In order to perform sideband separation, the correlator must integrate for an
integral number of Walsh cycles.  The registers used to control and monitor
synchronization of the integrations are described here.

\begin{description}

\rwreg{syncsel} This register selects the sync signal used to drive integration
timing.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize sel}
\end{bytefield}

The sync signal selection determines the units of the \verb|integ_time|
register.  The four choices are:

\begin{description}
\item[0] Use the 1024~PPS signal to define the integration units.
\item[1] Use the HB signal to define the integration units.
\item[2] Use the SOWF signal to define the integration units.
\item[3] Use the 1~PPS signal to define the integration units.
\end{description}

\rwreg{integ\_time} This register sets the integration time in units of the
sync signal selected via the \verb|syncsel| register.  Changing the value of
this register resets the correlator's internals as well as the
\verb|integ_cnt| register.

\roreg{integ\_cnt} This register simply counts the number of integrations that
have completed.  When this register increments, a new integration is ready to
be read.  Changing the \verb|integ_time| register resets this register.

\roreg{sample\_cnt} The correlator always integrates in multiples of 32 samples
(since there are 16 lags per baseline and 2 samples per FPGA clock cycle).  If
the selected integration unit (see \verb|syncsel|) is not commensurate with 32
samples (e.g. the Heartbeat signal) then the number of samples per integration
can vary from integration to integration.  This register provides the number of
32-sample sub-integrations in the most recently completed integration.  It can
be used to properly average the data.  Since the integrated values are
pre-divided by 32 in the FPGA, the output values can be divided by this
register value directly to get the average of the integrated products.

\roreg{subint\_cnt} This register indicates how far along the current
integration is.  It is in units of the sync signal selected via the
\verb|syncsel| register.  It counts from 0 to $integ\_time - 1$, then starts
over.

\rwreg{refant} This register selects the reference \emph{input} (NB: \emph{not}
antenna) that is common to all eight of the computed baselines, including the
auto-correlation ``baseline''.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{3}{\scriptsize ref\\ant}
\end{bytefield}

\bramn{rx0/usb\_real}
\bramn{rx0/usb\_imag}
\bramn{rx0/lsb\_real}
\bramn{rx0/lsb\_imag}
\bramn{$\vdots$}
\bramn{rx7/usb\_real}
\bramn{rx7/usb\_imag}
\bramn{rx7/lsb\_real}
\brams{rx7/lsb\_imag} These shared BRAMs hold the integrated 16~lag spectra for
the upper and lower sidebands of each of the eight computed baselines.  The
\verb|rx0/usb_real| BRAM contains the integrated real component of the upper
sideband (USB) of input0 times the complex conjugate of the reference input.
The \verb|rx7/lsb_imag| BRAM contains the integrated imaginary component of the
lower sideband (USB) of input7 times the complex conjugate of the reference
input.  Note that some baselines can have a conjugation convention that differs
from MIRIAD's conjugation convention depending on which input is chosen to be
the reference input and which antennas are connected to which inputs.  The 16
lags are stored from lag~-8 to lag~+7.

\roregn{phsw\_bal/0}
\roregn{$\vdots$}
\roregs{phsw\_bal/7} These registers indicate the \emph{phase switching
balance} for the most recently completed integration for each of the baselines.
During the integration, a counter (accumulator, really) counts +1 for each
sample where the inputs were in the same 90 degree phase switch state and -1
for each sample where the inputs were in different 90 degree phase switch
states.  For optimum sideband separation, the inputs should have an equal
number of samples while in the same and different 90 degree phase switching
states, so ideally this output should read zero.  If it is positive, then there
that many more samples with the same 90 degree phase switch state.  If it is
negative, then there that many more samples with different 90 degree phase
switch state.  Note that the count is in FPGA cycles, which is half the number
of data samples (due to demux-by-2 data).

\roreg{uptime} The uptime register is a 32~bit counter that counts seconds
since the FPGA started running.  It cannot be reset (other than reprogramming
the FPGA) and is not synchronized with any other 1 PPS source.

\rwreg{wdelay} This register adjusts the delay applied to the Walsh inputs to
align them with the data out from the correlator.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{26}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{6}{\scriptsize wdelay}
\end{bytefield}

The total delay needed is calculated to be 65, but to accommodate errors in the
calculation, a variable delay element is provided.  The range of valid values
for this register are 0 to 63.  Some of the estimated delay is built in to the
design already.  The estimated value required for this register is 32.  Once a
good value is determined empirically, it will be hard-coded into the design and
this register will be removed.

\end{description}

\subsection{Snapshot Data}

The design includes a snapshot block that can be used to capture some input
samples to help set the upstream threshold registers and other diagnostic
purposes.

\begin{description}

\rwreg{snap/ctrl} This register controls the snapshot block.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize trg}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize en}}
\end{bytefield}

A 0 to 1 transition of bit~0 (en) enables a snapshot sequence.  Once the
snapshot sequence is enabled, the data capture will begin immediately if bit~1
(trg) is 1 or on the next selected sync pulse (see \verb|syncsel|) if bit~1
(trg) is 0.

\roreg{snap/addr} During data capture, this register provides the address
withing the shared BRAMs to which the data are being written.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{21}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{11}{snap address}
\end{bytefield}

When the data capture is complete, the address holds at the final value of
2047.  The data capture completes in 8~\textmu s, so this register is useful
primarily when the data capture is setup to begin on the next sync pulse
(otherwise it is unlikely that any value other than 2047 will be observed in
this register).

\filbreak
\bramn{snap/in0123}
\brams{snap/in4567} These shared BRAMs hold the snap shot data.  Each BRAM is
2048 words deep and stores data for the four inputs implied by its name.
Within a BRAM, each 32~bit word stores two complex samples for all four inputs.
The \MSB holds two complex samples of the BRAM's lowest numbered input; the
\LSB holds two complex samples of the BRAM's highest numbered input.  Within a
byte, the two \MSbs represent the real component of the first (in time) of the
byte's two complex samples.  Thus, each shared BRAM can hold 4096 complex
samples for four inputs.  The storage format for the first word (BRAM address
0) of \verb|snap/in0123| is shown in the following diagram (\verb|snap/in4567|
is similar).

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{2}{\scriptsize in0 \\ re0} &
  \bitbox{2}{\scriptsize in0 \\ im0} &
  \bitbox{2}{\scriptsize in0 \\ re1} &
  \bitbox{2}{\scriptsize in0 \\ im1} &
  \bitbox{2}{\scriptsize in1 \\ re0} &
  \bitbox{2}{\scriptsize in1 \\ im0} &
  \bitbox{2}{\scriptsize in1 \\ re1} &
  \bitbox{2}{\scriptsize in1 \\ im1} &
  \bitbox{2}{\scriptsize in2 \\ re0} &
  \bitbox{2}{\scriptsize in2 \\ im0} &
  \bitbox{2}{\scriptsize in2 \\ re1} &
  \bitbox{2}{\scriptsize in2 \\ im1} &
  \bitbox{2}{\scriptsize in3 \\ re0} &
  \bitbox{2}{\scriptsize in3 \\ im0} &
  \bitbox{2}{\scriptsize in3 \\ re1} &
  \bitbox{2}{\scriptsize in3 \\ im1}
\end{bytefield}

\end{description}

\section{dbe\_xaui\_corr}

The dbe\_xaui\_corr design receives two signals (i.e. streams of data) from two
different iBobs via XAUI.  It must time-align these two incoming signals, sum
them, and then process and format the final summed signal for recording to the
Mark 5 data recorder.  The design also contains a digital noise generator that
can be used in place of the final sum for engineering purposes.

\subsection{XAUI alignment and monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
summing.  The design will automatically align the two XAUI streams and, if ever
necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.  Setting the
bit~0 to 1 will reset the XAUI core itself (rarely needed).  Setting bit 1 to 1
will reset the counters associated with XAUI monitoring.  Setting bit 2 to 1
will reset the registers that capture the relative delays of the two XAUI
links.
\end{description}

{}xaui0/linkdown\_cnt
xaui0/period
xaui0/period\_err
xaui0/period\_err\_cnt
xaui0/sync\_cnt

{}xaui0/almost\_full
xaui0/rx\_empty\_cnt
xaui0/rx\_linkdown
xaui0/valid
xaui1/almost\_full
xaui1/linkdown\_cnt
xaui1/period
xaui1/period\_err
xaui1/period\_err\_cnt
xaui1/rx\_empty\_cnt
xaui1/rx\_linkdown
xaui1/sync\_cnt
xaui1/valid

{}correlate
delay\_adj
ibob\_lwip/ethlite
ibob\_lwip/macbits
insel
noise/arm
noise/seed
onepps\_sync/arm1pps
onepps\_sync/arm1pps\_ack
outsel
pol0/gainctrl0
pol0/gainctrl1
pol0/gainreset
shiftctrl\_reg
sma1pps\_sel
smavsisel
snap/addr
snap/bram
snap/ctrl
trig\_capt
xaui\_summer/corr\_out-4
xaui\_summer/corr\_out-8
xaui\_summer/corr\_out0
xaui\_summer/corr\_out4
xaui\_summer/corr\_out8
xaui\_summer/delay0
xaui\_summer/delay1


\section{dbe\_adc\_single}

\end{document}
