\documentclass[12pt]{article}
\usepackage[usenames]{color} %used for font color
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{bytefield}
\usepackage{amssymb} %maths
\usepackage{amsmath} %maths
\usepackage[utf8]{inputenc} %useful to type directly accentuated characters

% PDF Bookmarks and hyperref stuff
\usepackage[
  bookmarks=true,
  bookmarksnumbered=true,
  colorlinks=true,
  filecolor=blue,
  linkcolor=blue,
  urlcolor=blue,
  hyperfootnotes=true
]{hyperref}

% the following command sets a 1-inch left margin.
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

% set width of the text - what is left will be the right
% margin; in this case, right margin is
% 8.5in - 1in - 6.5in = 1in.
\setlength{\textwidth}{6.5in}

% set top margin "extras" to 0 to get a 1 inch usable margin
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}

% set text length to 9 inches
\setlength{\textheight}{9in}

\author{David MacMahon}
\title{VLBI Phased Array \\ iBob and BEE2 \\ Programmer's Guide}

\begin{document}
\maketitle
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newlength{\itemseporig}
\setlength{\itemseporig}{\itemsep}

% Put new commands here
\newcommand{\tighten}{
  \setlength{\itemsep}{-\parskip}
}
\newcommand{\loosen}{
  \setlength{\itemsep}{\itemseporig}
}
\newcommand{\LSB}{least significant byte }
\newcommand{\LSn}{least significant nybble }
\newcommand{\LSb}{least significant bit }
\newcommand{\LSns}{least significant nybbles }
\newcommand{\LSbs}{least significant bits }
\newcommand{\MSb}{most significant bit }
\newcommand{\MSbs}{most significant bits }
\newcommand{\MSB}{most significant byte }
\newcommand{\devitem}[2]{\item[#1] [#2] \\ }
\newcommand{\rwreg}[1]{\devitem{#1}{R/W register}}
\newcommand{\rwregn}[1]{\item[#1] {} \tighten} % For "stacked" rwregs
\newcommand{\rwregs}[1]{\devitem{#1}{R/W registers} \loosen} % Ends stacked rwregs
\newcommand{\roreg}[1]{\devitem{#1}{R register}}
\newcommand{\roregn}[1]{\item[#1] {} \tighten} % For "stacked" roregs
\newcommand{\roregs}[1]{\devitem{#1}{R registers} \loosen} % Ends stacked roregs
\newcommand{\bram}[1]{\devitem{#1}{Block RAM}}
\newcommand{\bramn}[1]{\item[#1] {} \tighten} % For "stacked" brams
\newcommand{\brams}[1]{\devitem{#1}{Block RAM} \loosen} % Ends stacked brams
\newcommand{\degree}[1]{$#1^{\circ}$}

\begin{abstract}
Describes the registers and devices in the various iBob and BEE2 designs used
in the VLBI phased array processor for CARMA and SMA.
\end{abstract}

\section{Gateware Versions}

The history of the gateware designs has two major epochs: real and complex.
The real epoch covers the original designs, which processed the signal as real
(i.e. non-complex) data.  Due to limitations in dealing with real data, namely
lack of phase information and control, the gateware designs were modified to
convert the real signal into complex form.  These designs dealing with complex
data comprise the complex epoch.

Within each epoch, registers and devices have been added, removed, and renamed.
Instead of attempting to describe all revisions of the gateware, this document
only describes specific versions of the gateware as noted in each section.  The
complete history for the various designs are in a Git repository.  The official
Git repository is only available via (non-public) ssh using this URL:

\begin{center}
\nolinkurl{git@vlbi-devel.cfa.harvard.edu:phringes.git}
\end{center}

A publicly visible mirror is available using this URL:

\begin{center}
\url{http://astro.berkeley.edu/~davidm/phringes.git}
\end{center}

\section{ibob\_phased\_array\_2k}

This section documents the ibob\_phased\_array\_2k\_2011\_Jan\_27\_1903 design.

In addition to synchronizing internal timing signals with external timing
signals.  The ibob\_phased\_array\_2k design has a few critical registers that
must be set to non-zero values for proper operation.  These registers are
briefly listed here; full details are provided below.

\begin{description}
\rwreg{start\_xaui} Must be 1 to enable XAUI transmission as well as the clock
output for the BEE2 calibration correlator.
\rwregs{gain0 - gain3} At least one gain register must be non-zero to get
non-zero output through to the DBE.
\end{description}

  \subsection{Synchronization}

Different observatories use different synchronization and phase switching
schemes.  The ibob\_phased\_array\_2k design accommodates the schemes used at
SMA and CARMA.  Additionally, the design requires an external 1~PPS pulse with
which it synchronizes internally generated sync signals used with downstream
systems.

SMA phase switching is based on a Heartbeat (HB) signal with frequency
$\frac{52 \, \mathrm{MHz}}{2^{19}} \approx 99.182 \, \mathrm{Hz}$.  This signal
is generated on board from the 256 MHz FPGA clock and is synchronized with the
external SMA Start of Walsh Frame (SOWF) signal using the \verb|armsowf|
command.  An internal SOWF signal is also generated on board synchronized with
the external SOWF signal.  The frequency of SOWF is $\frac{52 \,
\mathrm{MHz}}{2^{25}} \approx 1.550 \, \mathrm{Hz}$.

CARMA phase switching is based on a 1024~PPS signal.  This signal is generated
on board from the 256~MHz FPGA clock and is synchronized with the external
1~PPS signal using the \verb|arm1pps| command.  An internal 1~PPS signal is
also generated on board synchronized with the external 1~PPS.

The design also uses the internally generated 1024~PPS and 1~PPS signals for
other purposes (e.g. XAUI synchronization and synchronous noise source seeding)
independent of the phase switching scheme being used, so the external 1~PPS
must always be supplied and the internal 1~PPS must always be synchronized to
it via the \verb|arm1pps| command.

%To facilitate synchronized seeding of noise sources on different devices, the
%noise generators are armed via software.  This causes them to re-seed on the
%next rising edge of the internal 1~PPS signal.  The internal 1~PPS is generated
%by counting clock cycles and can be synchronized with one or the other of the
%ADCs sync pulses.

\begin{description}
\rwreg{ppssel} Selects the ADC sync pulse to which the internally generated
1~PPS signal will be synchronized.

0: Select ADC0 sync signal (typically for CARMA) \\
1: Select ADC1 sync signal (typically for SMA)

\rwreg{onepps\_sync/arm1pps} A 0 to 1 transition of the \LSb of this register
will arm the internal 1~PPS generator to re-synchronize with the next rising
edge of the selected sync pulse.  This register is not often used directly
since (re-)arming is normally done via the \verb|arm1pps| command.

\roreg{onepps\_sync/arm1pps\_ack} A 1 to 0 transition of the \LSb of
\verb|onepps_sync/arm1pps| clears (i.e. sets to zero) this register.  This
register is set to 1 on the rising edge of the next sync pulse that
re-synchronizes the internal 1~PPS generator.  This can be used to verify that
the internal 1~PPS generator did indeed re-synchronize after being armed.  This
register is not often used directly since (re-)arming is normally done via the
\verb|arm1pps| command.

\rwreg{hb\_sync/arm\_sowf} A 0 to 1 transition of the \LSb of this register
will arm the internal HB and SOWF generators to re-synchronize with the next
rising edge of the external SOWF signal.  This register is not often used
directly since (re-)arming is normally done via the \verb|armsowf| command.

\roreg{hb\_sync/armsowf\_ack} A 1 to 0 transition of the \LSb of
\verb|hb_sync/arm\_sowf| clears (i.e. sets to zero) this register.  This
register is set to 1 on the next rising edge of the external SOWF signal.  This
can be used to verify that the internal HB and SOWF generators did indeed
re-synchronize after being armed.  This register is not often used directly
since (re-)arming is normally done via the \verb|armsowf| command.

\end{description}

  \subsection{Input Selection}

\begin{description}

\rwreg{insel}  Input selection.  Uses one bit per demux path per input.

0: Select ADC \\
1: Select noise source

Examples:
\begin{description}

\item[0x0000] Select ADC for all demux paths of all inputs.
\item[0x0001] Select noise source for demux path 0 of input0, select ADC  for
               all other demux paths.
\item[0x000F] Select noise source for all demux paths of input 0, select ADC
               for all other inputs.
\item[0xFFFF] Select noise source for all demux paths of all inputs.
\item[0xF000] Select noise source for all demux paths of input 3, select ADC
               for all other inputs.
\item[0xC000] Select noise source for demux paths 2 and 3 of input 3, select
               ADC for all other inputs.
\end{description}
\end{description}

  \subsection{Noise Generators}

\begin{description}

\rwreg{noise/arm}  A 0 to 1 transition of the \LSb of each
nybble arms that input's noise generator.  The least significant nybble
corresponds to input0.  A value of 0x0011 will arm the noise generators for
input0 and input1.  A value of 0x1111 will arm all noise generators.

Once a noise generator is armed, it will re-seed starting on the next internal
1~PPS rising edge.  This can be used to synchronously seed noise generators
across multiple devices or within one device.

\filbreak
\rwregn{noise/seed/0}
\rwregn{noise/seed/1}
\rwregn{noise/seed/2}
\rwregs{noise/seed/3} Sets 32~bit seed for noise generators for corresponding
inputs.  Because the inputs are demultiplexed by 4, each noise generator
actually contains two noise generators that each output two independent
normally distributed values each.  The 32~bit seed is actually split into two
16~bits seeds to seed the two contained noise generators.  Using a seed whose
two halves are identical (i.e.\ a multiple of 65537) will result in a signal
that has a lag-2 correlation coefficient of 1 resulting in a non-flat spectrum.

\end{description}

  \subsection{Delay Core}

The Delay Core consists of a coarse delay (in units of FPGA clock cycles), a
fine delay (in units of ADC sample clock cycles), and a sub-sample delay (in
units of 1/16 an ADC sample clock cycle).  The sub-sample delay is implemented
using a quadrature fractional delay FIR filter that not only does sub sample
delay, but also converts the signal to complex form.  Converting to complex
form involves mixing by a local oscillator at $\pm F_s/4$.  The sign of the LO
frequency is user selectable and determines whether the Delay Core's complex
output will consist of the positive or negative frequencies of the real input.
Selecting the negative frequencies will result in a frequency reversal and
conjugation relative the positive frequencies.  See the \verb|sbsel| register
for more details.

\begin{description}

\filbreak
\rwregn{delay0}
\rwregn{delay1}
\rwregn{delay2}
\rwregs{delay3} The 17 \LSbs of these registers specify the overall delay to be
applied to by each input's Delay Core.  The value written into these registers
can be computed as

\begin{align*}
register\_value &= 16 \cdot adc\_sample\_delay + 64 &(\mathrm{mod}\:2^{17}) \\
                &= \mathrm{round}(16.384 \cdot ns\_delay) + 64 &(\mathrm{mod}\:2^{17})
\end{align*}

For example, to obtain a delay of 123.456~ns, the value to use would be
computed as

\begin{align*}
register\_value &= \mathrm{round}(16.384 \cdot 123.456) + 64 &(\mathrm{mod}\:2^{17}) \\
                &= 2087
\end{align*}

Because of the 64 sample offset and modulo $2^{17}$ behavior, minimum delay is
obtained with a value of 64, while maximum delay is obtained with a value of
63.

\rwreg{sbsel} The \verb|sbsel| (sideband select) register specifies whether the
complex output will consist of the positive or negative frequencies of the real
input.  Each of the four \LSns (i.e. hex digits) of \verb|sbsel| corresponds
one input.  The \LSn specifies the sideband selection for input 0.  A value of
0 selects the positive frequencies; a value of 1 selects the negative
frequencies.  Writing 0x0100 will select positive frequencies for inputs~0,1,3
and negative frequencies for input2.

\end{description}

  \subsection{Phase Rotation}

After the Delay Core's conversion to complex, the signal passes through a phase
rotator.  The amount of phase rotation applied is a combination of the phase
offset introduced by fine delay, the phase value specified in the input's
\verb|phaseN| register, and the 0/90/180/270 degree phase switching specified
by the input's current phase switching state.  The phase offset introduced by
fine delay is automatically compensated; no user input is required.  The
\verb|phaseN| registers are described here and the phase switching states are
described in a separate subsection.

\begin{description}

\filbreak
\rwregn{phase0}
\rwregn{phase1}
\rwregn{phase2}
\rwregs{phase3} These registers specify the amount of user-specified phase
rotation to be applied to each input's complex signal.  The 12 least
significant bits of these registers are used.  The resolution is therefore
$\frac{2 \pi}{2^{12}}$ radians per step or $\frac{360}{2^{12}}$ degrees per
step (i.e. approximately 88 millidegrees per step).  The value written into
these registers and be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(
                      phase\_radians \cdot \frac{2^{12}}{2 \pi}
                    \right) \\
                &   \:\text{or} \\
register\_value &=  \mathrm{round}\left(
                      phase\_degrees \cdot \frac{2^{12}}{360}
                    \right)
\end{align*}

For example, to phase
rotate a given input by 30 degrees, the value to use would be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(30 \cdot \frac{2^{12}}{360}\right) \\
                &=  341
\end{align*}

\end{description}

  \subsection{Phase Switching}

As mentioned elsewhere, the design supports both SMA and CARMA phase switching
schemes.  Both observatories use nested Walsh functions whereby the 180 degree
phase switching cycle completes once per 90 degree phase switching state.  The
Wash functions themselves are stored in two shared block RAM lookup tables.
One table is for the 180 degree phase switch cycle and the other table is for
the 90 degree phase switching cycle.  Each entry (i.e. row) in a Walsh table is
32 bits wide.  Each bit (i.e. column) corresponds to a given Walsh function.
Each input uses a user specified column for both the 90 and 180 degree Walsh
functions.  To provide the simplest and most versatile interface, the Walsh
tables are stored in unrolled form.

\begin{description}

\rwreg {walsh/syncsel} This register is used to select the timing of the Walsh functions.  A value of 0 selects the internal 1024~PPS (for CARMA).  A value of 1 selects the internal HB signal (for SMA).

\rwreg{walsh/colsel} This register is used to specify which columns (i.e. bits)
of the Walsh tables to use for each input.  Each input is controlled by one
byte of this register.  Input~0 uses the \LSB of this register.  Only the five
\LSbs of each byte are used to select columns~0 through 31.  Column~0 is the
\MSb of the 32~bit Walsh table entries.

\bramn{walsh/table/90} \brams{walsh/table/180} These shared block RAMs must be
programmed with the unrolled Walsh tables.  Table \verb|walsh/table/90| is for
the 90 degree phase switching states while table \verb|walsh/table/180| is for
the 180 degree phase switching states.  Each table is 2048 entries long.  Each
entry is 32~bit wide.  The \MSb of each 32-bit entry corresponds to column~0 of
the (up to) 32~column Walsh table.  The Walsh tables are addressed by a counter
that increments every phase switching state (i.e. every 1024~PPS for CARMA;
every HB for SMA) and is reset at the end of every Walsh function cycle (i.e.
every 1~PPS for CARMA and every SOWF for SMA).  Only the first N entries need
to be populated, where N is the number of phase switching states per complete
phase switching cycle (i.e. 1024 for CARMA, 64 for SMA).

\end{description}

  \subsection{2-Bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  The calibration correlator gets 2~bit data
(at the ADC sample rate) from all inputs.  The quantization to 2~bits is
controlled by user specified threshold values.  The 2~bit coding represents
four distinct values: -3, -1, +1, +3.

\begin{description}

\rwregn{quant/thresh0}
\rwregn{quant/thresh1}
\rwregn{quant/thresh2}
\rwregs{quant/thresh3}  These registers set the thresholding level used for
quantizing each input to 2~bits.  When using a digital noise source as an
input, a threshold value of 16 results in a $\left\{\frac{1}{6}, \frac{2}{6},
\frac{2}{6}, \frac{1}{6}\right\}$ distribution in the 2~bit quantized values.

The quantized value for a given input value of $x$ and threshold value $thresh$
is determined according to the equations shown here.  Note that the output
value for a zero valued input alternates between -1 and +1.

\begin{align*}
           &\,x <= -thresh &\Rightarrow -3 \\
-thresh <  &\,x < 0        &\Rightarrow -1 \\
           &\,x = 0        &\Rightarrow \pm1 \\
      0 <  &\,x < thresh   &\Rightarrow +1 \\
 thresh <= &\,x            &\Rightarrow +3
\end{align*}

\end{description}

  \subsection{8-bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  Before being sent to the DBE, the four
8~bit input signals are summed together then scaled and rounded back to 8~bits.
Before the sum each input signal is multiplied by a gain factor.  This gain
factor is intended to weight the inputs according to system temperature, but
thus far they have been used only to scale all inputs equally or to zero out an
input to exclude it from the sum.  The sum is scaled by~$\frac{1}{2}$
or~$\frac{1}{4}$ and then rounded to 8~bits prevent overflow.

\begin{description}

\rwregn{gain0}
\rwregn{gain1}
\rwregn{gain2}
\rwregs{gain3} These registers control the gain factor for each input.  Only
the 8 \LSbs are used.  They are currently interpreted as an unsigned number
with 7 fractional bits.  Thus, the range of gain values that can be applied to
each input is~$0$ to~$1\frac{127}{128}$.

\rwreg{summer/shift} Set this to~0 to scale the sum by~$\frac{1}{2}$ (e.g. for
independent noise dominated inputs).  Set this to~1 to scale the sum
by~$\frac{1}{4}$ (e.g. for coherent inputs).

\end{description}

  \subsection{XAUI}

The sum of the phased inputs is sent to the DBE via the XAUI0 connector.  The
2-bit quantized inputs are sent to the calibration correlator via the XAUI1
connector.  XAUI data transmission is \emph{dis}abled by default and must be
explicitly enabled via software (see below).

\begin{description}

\rwreg{start\_xaui} Writing a 1 to this register enables a divide-by-2 counter
that drives the BEE2 calibration correlator's \verb|usr2_clk| input and the two
XAUI links' data valid inputs (data is de-muxed by two for XAUI transmission)
thereby enabling transmission over the XAUI links.

Writing a 0 (the default) disables the divide-by-two counter that drives the
BEE2 calibration correlator's \verb|usr2_clk| input and the two XAUI links'
data valid inputs (data is de-muxed by two for XAUI transmission).  Whether
this actually disables transmissions over the XAUI links depends on whether the
counter is stopped in the 0 state or the 1 state.  Future designs may remove
this ambiguity.

\roregn{xaui\_0/rx\_linkdown}
\roregs{xaui\_1/rx\_linkdown} A value of 1 indicates a ``link down'' status on
the (unused) receive side of the indicated XAUI connection, which strongly
implies a similar status for its transmit side.

\end{description}

\filbreak
  \subsection{Front Panel SMA Output}

\begin{description}

\rwreg{smasel} Selects which signal to output over the front panel \verb|SMA0|
connector.

\begin{description}

\item[0] Outputs a 128~MHz square wave (50\% duty cycle) if XAUI output is
enabled (i.e. register \verb|start_xaui| is 1), otherwise a constant 0 or 1.
Future designs may remove this ambiguity.

\item[1] Outputs a constant 0.

\end{description}

\rwreg{monsel} Selects which signal to output over the front panel \verb|SMA1|
connector.

\begin{description}

\item[0] Outputs a constant 0.

\item[1] Outputs the internal 1024~PPS signal.

\item[2] Outputs the internal Heartbeat (HB) signal.

\item[3] Outputs the internal Start of Walsh Frame (HB) signal.

\item[4] Outputs the internal 1~PPS signal.

\item[5] Outputs the sampled sync0 signal (from ADC0)

\item[6] Outputs the sampled sync1 signal (from ADC1)

\end{description}

\end{description}

\filbreak
  \subsection{Front Panel LEDs}
\begin{description}
\item[LED0] Not used.
\item[LED1] Not used.
\item[LED2] Briefly blinks on each rising edge of the sync0 input.
\item[LED3] Not used.
\item[LED4] Not used.
\item[LED5] Not used.
\item[LED6] Not used.
\item[LED7] Not used.
\item[LED8] Indicates FPGA is configured (non-functional on some iBobs).
\end{description}

\section{bee2\_complex\_corr}

This section documents the bee2\_complex\_corr\_floating\_2011\_Feb\_07\_2108
design.

The bee2\_complex\_corr design receives 2+2 bit samples (i.e. 2 real bits and 2
imaginary bits per sample) from a total of eight inputs (two IPAs).  It cross
correlates one of these signals (user selectable) with itself and the other
seven inputs.  Each of the 7 cross-correlations and 1 auto-correlation consists
of 16 lags (-8 to +7).  In addition to the data samples, the design also
receives sync and 90 degree phase state information from the IPAs over the XAUI
links' out of band channel.  This allows the correlator to perform sideband
separation, producing both upper and lower sideband lag spectra for each
baseline.

\subsection{Input numbering}

The four signals arriving over XAUI1 are considered to be input0 through
input3.  The four signals arriving over XAUI0 are considered to be input4
through input7.  Note that the higher number XAUI port contains the lower
number inputs and vice versa.

\subsection{XAUI alignment and monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
correlation.  The design will automatically align the two XAUI streams and, if
ever necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.  Setting the
\LSb (bit 0) to 1 will reset the XAUI core itself (rarely needed).  Setting bit
1 to 1 will reset the counters associated with XAUI monitoring.  Setting bit 2
to 1 will reset the registers that capture the relative delays of the two XAUI
links.

\roregn{xaui0/linkdown\_cnt}
\roregs{xaui1/linkdown\_cnt} Indicates how many times the link has gone down
(i.e. transitioned from up to down).  Under normal operations this register
should read~0, though it may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period}
\roregs{xaui1/period}
Indicates the number of FPGA (256 MHz) clock cycles between the most recently
received 1024~PPS pulse and the previous one.  Under normal operations, this
register should read~250000.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period\_err}
\roregn{xaui1/period\_err}
\roregn{xaui0/period\_err\_cnt}
\roregs{xaui1/period\_err\_cnt}
The XAUI monitoring logic constantly monitors the number of FPGA cycles between
1024~PPS pulses.  It counts the number of period errors and remembers the most
recent erroneous period value.  The \verb|xauiN/period_err_cnt| registers
indicate the total number of erroneous periods detected.  Under normal
operations, these registers should read~0.  The \verb|xauiN/period_err|
registers indicate the most recent erroneous period value.  Under normal
operations, these registers should read~0 (i.e. no erroneous period measured).
These registers are reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/sync\_cnt}
\roregs{xaui1/sync\_cnt} This register indicates the total number of 1024~PPS
pulses received.  Since it is a 32~bit counter, it will roll over approximately
every 48.5 days.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/rx\_empty\_cnt}
\roregs{xaui1/rx\_empty\_cnt} Indicates how many times the XAUI FIFO has
underflowed.  Under normal operations this register should read~0, though it
may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/almost\_full}
\roregs{xaui1/almost\_full} Indicates the current state of the XAUI's
\verb|almost_full| status bit.  Under normal operation, this register should
read~0.

\roregn{xaui0/rx\_linkdown}
\roregs{xaui1/rx\_linkdown} Indicates the current state of the XAUI's
\verb|link_down| status bit.  Under normal operation, this register should
read~0.

\roregn{xaui0/valid}
\roregs{xaui1/valid} The two \LSbs of this register contain the current and
previous value of the XAUI block's \verb|valid| status bit.  Since this status
bit should toggle every clock cycle, this register should read~1 or~2 under
normal operation.

\roregn{xaui\_aligner/delay0}
\roregs{xaui\_aligner/delay1} These registers indicate the number of cycles
from the stream's incoming 1024~PPS and the reference 1024~PPS.  Since the
reference 1024~PPS is just a 32 cycle delayed version of XAUI0's 1024~PPS,
\verb|xaui_aligner/delay0| should always read 32.  Under normal operations,
\verb|xaui_aligner/delay1| should be $32\pm32$, but usually it will be
$32\pm4$.
\end{description}

\subsection{Synchronization and Integration}

In order to perform sideband separation, the correlator must integrate for an
integral number of Walsh cycles.  The registers used to control and monitor
synchronization of the integrations are described here.

\begin{description}

\rwreg{syncsel} This register selects the sync signal that specifies the time
granularity of the integrations.  It determines the units of the
\verb|integ_time| register.  The four choices are:

\begin{description}
\item[0] Use the 1024~PPS signal to define the integration units.
\item[1] Use the HB signal to define the integration units.
\item[2] Use the SOWF signal to define the integration units.
\item[3] Use the 1~PPS signal to define the integration units.
\end{description}

\rwreg{integ\_time} This register sets the integration time in units of the
sync signal selected via the \verb|syncsel| register.  Changing the value of
this register resets the correlator's internals as well as the
\verb|integ_cnt| register.

\roreg{integ\_cnt} This register simply counts the number of integrations that
have completed.  When this register increments, a new integration is ready to
be read.  Changing the \verb|integ_time| register resets this register.

\roreg{sample\_cnt} The correlator always integrates in multiples of 32 samples
(since there are 16 lags per baseline and 2 samples per FPGA clock cycle).  If
the selected integration unit (see \verb|syncsel|) is not commensurate with 32
samples (e.g. the Heartbeat signal) then the number of samples per integration
can vary from integration to integration.  This register provides the number of
32-sample sub-integrations in the most recently completed integration.  It can
be used to properly average the data.  To determine the number of individual
samples integrated, multiply the value of this register by 32.

\roreg{subint\_cnt} This register indicates how far along the current
integration is.  It is in units of the sync signal selected via the
\verb|syncsel| register.  It counts from 0 to $integ\_time - 1$, then starts
over.

\rwreg{refant} This register selects the reference \emph{input} (NB: \emph{not}
antenna) that is common to all eight of the computed baselines, including the
auto-correlation ``baseline''.

\filbreak
\bramn{rx0/usb\_real}
\bramn{rx0/usb\_imag}
\bramn{rx0/lsb\_real}
\bramn{rx0/lsb\_imag}
\bramn{$\vdots$}
\bramn{rx7/usb\_real}
\bramn{rx7/usb\_imag}
\bramn{rx7/lsb\_real}
\brams{rx7/lsb\_imag} These shared BRAMs hold the integrated 16~lag spectra for
the upper and lower sidebands of each of the eight computed baselines.  The
\verb|rx0/usb_real| BRAM contains the integrated real component of the upper
sideband (USB) of input0 times the complex conjugate of the reference input.
The \verb|rx7/lsb_imag| BRAM contains the integrated imaginary component of the
lower sideband (USB) of input7 times the complex conjugate of the reference
input.  Note that some baselines can have a conjugation convention that differs
from MIRIAD's conjugation convention depending on which input is chosen to be
the reference input and which antennas are connected to which inputs.  The 16
lags are stored from lag~-8 to lag~+7.

\roregn{phsw\_bal/0}
\roregn{$\vdots$}
\roregs{phsw\_bal/7} These registers indicate the \emph{phase switching
balance} for the most recently completed integration for each of the baselines.
During the integration, a counter (accumulator, really) counts +1 for each
sample where the inputs were in the same 90 degree phase switch state and -1
for each sample where the inputs were in different 90 degree phase switch
states.  For optimum sideband separation, the inputs should have an equal
number of samples while in the same and different 90 degree phase switching
states, so ideally this output should read zero.  If it is positive, then there
that many more samples with the same 90 degree phase switch state.  If it is
negative, then there that many more samples with different 90 degree phase
switch state.  Note that the count is in FPGA cycles, which is half the number
of data samples (due to demux-by-2 data).

\rwreg{wdelay} This register adjusts the delay applied to the Walsh inputs to
align them with the data out from the correlator.  This delay is calculated to
be 65, but to accommodate errors in the calculation, a variable delay element
is provided.  The range of valid values for this register are 0 to 63.  Some of
the estimated delay is built in to the design already.  The estimated value
required for this register is 32.  Once a good value is determined empirically,
it will be hard-coded into the design and this register will be removed.

\end{description}

\subsection{Status and Data Monitoring}

The design includes an uptime counter and a snapshot block.  The uptime counter
counts in seconds and cannot be be reset without reprogramming the FPGA.  The
snapshot block can be used to capture some input samples to help set the
upstream threshold registers.

\begin{description}

\roreg{uptime} The uptime register is a 32~bit counter that counts seconds
since the FPGA started running.  It cannot be reset (other than reprogramming
the FPGA) and is not synchronized with external 1 PPS.

\rwreg{snap/ctrl} This register controls the snapshot block.  A 0 to 1
transition of the \LSb enabled a snapshot sequence.  Once the snapshot
sequence is enabled, the data capture will begin immediately if bit~1 is 1 or
on the next selected sync pulse (see \verb|syncsel|) if bit~1 is 0.

\roreg{snap/addr} During data capture, this register provides the address
withing the shared BRAMs to which the data are being written.  When the data
capture is complete, the address holds at the final value of 2047.  The data
capture completes in 8~\textmu s, so this register is useful primarily when the
data capture is setup to begin on the next sync pulse (otherwise it is unlikely
that any value other than 2047 will be observed in this register).

\bramn{snap/in0123}
\brams{snap/in4567} These shared BRAMs hold the snap shot data.  Each BRAM is
2048 words deep and stores data for the four inputs implied by its name.
Within a BRAM, each 32~bit word stores two complex samples for all four inputs.
The \MSB holds two complex samples of the BRAM's lowest numbered input; the
\LSB holds two complex samples of the BRAM's highest numbered input.  Within a
byte, the two \MSbs represent the real component of the first (in time) of the
byte's two complex samples.  Thus, each shared BRAM can hold 4096 complex
samples for four inputs.  The storage format for the first word (BRAM address
0) of \verb|snap/in0123| is shown in the following diagram (\verb|snap/in4567|
is similar).\\

\centering
\settowidth{\bitwidth}{\scriptsize in0}
\begin{bytefield}{32}
  \bitbox[]{1}{\rotatebox{90}{\scriptsize MSb}}
  \bitbox[]{30}{} &
  \bitbox[]{1}{\rotatebox{90}{\scriptsize LSb}} \\
  \bitheader[b]{0,7,8,15,16,23,24,31} \\
  \bitbox{2}{\scriptsize in0 \\ re0} &
  \bitbox{2}{\scriptsize in0 \\ im0} &
  \bitbox{2}{\scriptsize in0 \\ re1} &
  \bitbox{2}{\scriptsize in0 \\ im1} &
  \bitbox{2}{\scriptsize in1 \\ re0} &
  \bitbox{2}{\scriptsize in1 \\ im0} &
  \bitbox{2}{\scriptsize in1 \\ re1} &
  \bitbox{2}{\scriptsize in1 \\ im1} &
  \bitbox{2}{\scriptsize in2 \\ re0} &
  \bitbox{2}{\scriptsize in2 \\ im0} &
  \bitbox{2}{\scriptsize in2 \\ re1} &
  \bitbox{2}{\scriptsize in2 \\ im1} &
  \bitbox{2}{\scriptsize in3 \\ re0} &
  \bitbox{2}{\scriptsize in3 \\ im0} &
  \bitbox{2}{\scriptsize in3 \\ re1} &
  \bitbox{2}{\scriptsize in3 \\ im1}
\end{bytefield}

\end{description}

\section{dbe\_xaui\_corr}

The dbe\_xaui\_corr design receives two signals (i.e. streams of data) from two
different iBobs via XAUI.  It must time-align these two incoming signals, sum
them, and then process and format the final summed signal for recording to the
Mark 5 data recorder.  The design also contains a digital noise generator that
can be used in place of the final sum for engineering purposes.

\subsection{XAUI alignment and monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
summing.  The design will automatically align the two XAUI streams and, if ever
necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.  Setting the
\LSb (bit 0) to 1 will reset the XAUI core itself (rarely needed).  Setting bit
1 to 1 will reset the counters associated with XAUI monitoring.  Setting bit 2
to 1 will reset the registers that capture the relative delays of the two XAUI
links.
\end{description}

{}xaui0/linkdown\_cnt
xaui0/period
xaui0/period\_err
xaui0/period\_err\_cnt
xaui0/sync\_cnt

{}xaui0/almost\_full
xaui0/rx\_empty\_cnt
xaui0/rx\_linkdown
xaui0/valid
xaui1/almost\_full
xaui1/linkdown\_cnt
xaui1/period
xaui1/period\_err
xaui1/period\_err\_cnt
xaui1/rx\_empty\_cnt
xaui1/rx\_linkdown
xaui1/sync\_cnt
xaui1/valid

{}correlate
delay\_adj
ibob\_lwip/ethlite
ibob\_lwip/macbits
insel
noise/arm
noise/seed
onepps\_sync/arm1pps
onepps\_sync/arm1pps\_ack
outsel
pol0/gainctrl0
pol0/gainctrl1
pol0/gainreset
shiftctrl\_reg
sma1pps\_sel
smavsisel
snap/addr
snap/bram
snap/ctrl
trig\_capt
xaui\_summer/corr\_out-4
xaui\_summer/corr\_out-8
xaui\_summer/corr\_out0
xaui\_summer/corr\_out4
xaui\_summer/corr\_out8
xaui\_summer/delay0
xaui\_summer/delay1


\section{dbe\_adc\_single}

\end{document}
