\documentclass[12pt]{article}
\usepackage[usenames]{color} %used for font color
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{bytefield}
\usepackage{amssymb} %maths
\usepackage{amsmath} %maths
\usepackage[utf8]{inputenc} %useful to type directly accentuated characters

% PDF Bookmarks and hyperref stuff
\usepackage[
  bookmarks=true,
  bookmarksnumbered=true,
  colorlinks=true,
  filecolor=blue,
  linkcolor=blue,
  urlcolor=blue,
  hyperfootnotes=true
]{hyperref}

% the following command sets a 1-inch left margin.
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

% set width of the text - what is left will be the right
% margin; in this case, right margin is
% 8.5in - 1in - 6.5in = 1in.
\setlength{\textwidth}{6.5in}

% set top margin "extras" to 0 to get a 1 inch usable margin
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}

% set text length to 9 inches
\setlength{\textheight}{9in}

\author{David MacMahon}
\title{VLBI Phased Array \\ iBob and BEE2 \\ Programmer's Guide}

\begin{document}
\maketitle
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newlength{\itemseporig}
\setlength{\itemseporig}{\itemsep}

% Put new commands here
\newcommand{\tighten}{
  \setlength{\itemsep}{-\parskip}
}
\newcommand{\loosen}{
  \setlength{\itemsep}{\itemseporig}
}
\newcommand{\LSB}{least significant byte }
\newcommand{\LSn}{least significant nybble }
\newcommand{\LSb}{least significant bit }
\newcommand{\LSns}{least significant nybbles }
\newcommand{\LSbs}{least significant bits }
\newcommand{\MSb}{most significant bit }
\newcommand{\MSbs}{most significant bits }
\newcommand{\MSB}{most significant byte }
\newcommand{\devitem}[2]{\item[#1] [#2] \\ }
\newcommand{\rwreg}[1]{\devitem{#1}{R/W register}}
\newcommand{\rwregn}[1]{\item[#1] {} \tighten} % For "stacked" rwregs
\newcommand{\rwregs}[1]{\devitem{#1}{R/W registers} \loosen} % Ends stacked rwregs
\newcommand{\roreg}[1]{\devitem{#1}{R register}}
\newcommand{\roregn}[1]{\item[#1] {} \tighten} % For "stacked" roregs
\newcommand{\roregs}[1]{\devitem{#1}{R registers} \loosen} % Ends stacked roregs
\newcommand{\bram}[1]{\devitem{#1}{Block RAM}}
\newcommand{\bramn}[1]{\item[#1] {} \tighten} % For "stacked" brams
\newcommand{\brams}[1]{\devitem{#1}{Block RAM} \loosen} % Ends stacked brams
\newcommand{\tinysh}[1]{\devitem{#1}{TinySh Command}}
\newcommand{\degree}[1]{$#1^{\circ}$}
\newcommand{\e}[1]{\ensuremath{\times 10^{#1}}}

\begin{abstract}
Describes the registers and devices in the various iBob and BEE2 designs used
in the VLBI phased array processor for CARMA and SMA.
\end{abstract}

%\tableofcontents
%\newpage

\section{Gateware Versions}

The history of the gateware designs has two major epochs: real and complex.
The real epoch covers the original designs, which processed the signal as real
(i.e. non-complex) data.  Due to limitations in dealing with real data, namely
lack of phase information and control, the gateware designs were modified to
convert the real signal into complex form.  These designs dealing with complex
data comprise the complex epoch.

Within each epoch, registers and devices have been added, removed, and renamed.
Instead of attempting to describe all revisions of the gateware, this document
only describes specific versions of the gateware as noted in each section.  The
complete history for the various designs are in a Git repository.  The
Git repository is available using one of these URLs:

\begin{center}
\nolinkurl{git://github.com/sma-wideband/phringes.git}
\end{center}

\begin{center}
\nolinkurl{http://astro.berkeley.edu/~davidm/phringes.git}
\end{center}

\newpage
\section{iBob Phased Array}

This section documents the ibob\_phased\_array\_2k\_2012\_Feb\_02\_1601 design.

In addition to synchronizing internal timing signals with external timing
signals.  The ibob\_phased\_array\_2k design has a few critical registers that
must be set to non-zero values for proper operation.  These registers are
briefly listed here; full details are provided below.

\begin{description}
\rwregs{gain0 - gain3} At least one gain register must be non-zero to get
non-zero output through to the DBE.
\end{description}

  \subsection{Synchronization}

Different observatories use different synchronization and phase switching
schemes.  The ibob\_phased\_array\_2k design accommodates the schemes used at
SMA and CARMA.  Additionally, the design requires an external 1~PPS pulse with
which it synchronizes internally generated sync signals used with downstream
systems.

SMA phase switching is based on a Heartbeat (HB) signal with frequency
$\frac{52 \, \mathrm{MHz}}{2^{19}} \approx 99.182 \, \mathrm{Hz}$.  This signal
is generated on board from the 256 MHz FPGA clock and is synchronized with the
external SMA Start of Walsh Frame (SOWF) signal using the \verb|armsowf|
command.  An internal SOWF signal is also generated on board synchronized with
the external SOWF signal.  The frequency of SOWF is $\frac{52 \,
\mathrm{MHz}}{2^{25}} \approx 1.550 \, \mathrm{Hz}$.

CARMA phase switching is based on a 1024~PPS signal.  This signal is generated
on board from the 256~MHz FPGA clock and is synchronized with the external
1~PPS signal using the \verb|arm1pps| command.  An internal 1~PPS signal is
also generated on board synchronized with the external 1~PPS.

The design also uses the internally generated 1024~PPS and 1~PPS signals for
other purposes (e.g. XAUI synchronization and synchronous noise source seeding)
independent of the phase switching scheme being used, so the external 1~PPS
must always be supplied and the internal 1~PPS must always be synchronized to
it via the \verb|arm1pps| command.

\begin{description}
\filbreak
\rwreg{ppssel} Selects the ADC sync pulse to which the internally generated
1~PPS signal will be synchronized.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Select ADC0 sync signal (typically for CARMA)
\item[1] Select ADC1 sync signal (typically for SMA)
\end{description}

\roreg{onepps\_sync/diff} This register captures the difference, in FPGA clock
cycles, between the external 1~PPS signal and the internally generated 1~PPS
signal.  Normally this register will read 0, but since the external 1~PPS
signal is not synchronous with the ADC sample clock, values of 1 or
256,000,000 are also acceptable.  Other values indicate a problem.

\roreg{onepps\_sync/ext\_cnt} This register contains the number of rising edges
seen on the external 1~PPS signal since the last re-arming of the internal
1~PPS signal.

\roreg{onepps\_sync/ext\_period} This register contains the number of FPGA clock
cycles between the two most recent rising edges seen on the external 1~PPS
signal.  It should read 256,000,000 $\pm$ 1.

\rwreg{onepps\_sync/arm1pps} A 0 to 1 transition of bit~0 of this register will
arm the internal 1~PPS generator to re-synchronize with the next rising edge of
the selected sync pulse.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\roreg{onepps\_sync/arm1pps\_ack} A 1 to 0 transition of bit~0 of
\verb|onepps_sync/arm1pps| clears (i.e. sets to zero) this register.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ack}}
\end{bytefield}

Bit~0 of this register is set to 1 on the rising edge of the next sync pulse
that re-synchronizes the internal 1~PPS generator.  This can be used to verify
that the internal 1~PPS generator did indeed re-synchronize after being armed.
This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\filbreak
\rwreg{sowfsel} Selects the source of the external SOWF signal to which the
internally generated SOWF signal will be synchronized.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Select GPIO 0 bit index 8 (aka J6 pin 17)
\item[1] Select ADC0 sync signal
\end{description}

\roreg{hb\_sync/diff} This register captures the difference, in FPGA clock
cycles, between the external SOWF signal and the internally generated SOWF
signal.  Normally this register will read 0, but since the external SOWF period
is not commensurate with the ADC clock period, values of 1 or 165,191,049 (plus
or minus a few clock cycles) are also acceptable.  Other values indicate a
problem.

\roreg{hb\_sync/ext\_cnt} This register contains the number of rising edges
seen on the external SOWF signal since the last re-arming of the internal SOWF
signal.

\roreg{hb\_sync/ext\_period} This register contains the number of FPGA clock
cycles between the two most recent rising edges seen on the external SOWF
signal.  It should read 165,191,049 $\pm$ 2.

\rwreg{hb\_sync/arm\_sowf} A 0 to 1 transition of bit~0 of this register will
arm the internal HB and SOWF generators to re-synchronize with the next rising
edge of the external SOWF signal.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

This register is not often used directly since (re-)arming is normally done via
the \verb|armsowf| command.

\roreg{hb\_sync/armsowf\_ack} A 1 to 0 transition of bit~0 of
\verb|hb_sync/arm\_sowf| clears (i.e. sets to zero) this register.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ack}}
\end{bytefield}

This register is set to 1 on the next rising edge of the external SOWF signal.
This can be used to verify that the internal HB and SOWF generators did indeed
re-synchronize after being armed.  This register is not often used directly
since (re-)arming is normally done via the \verb|armsowf| command.

\roreg{uptime} The uptime register is a 32~bit counter that counts seconds
since the FPGA started running.  It cannot be reset (other than reprogramming
the FPGA) and is not synchronized with any other 1 PPS source.

\end{description}

  \subsection{Input Selection}

\begin{description}

\rwreg{insel}  Input selection.  Uses two bits per time sample (i.e. demux
path) per input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{2}{\scriptsize in3 \\ t3} &
  \bitbox{2}{\scriptsize in3 \\ t2} &
  \bitbox{2}{\scriptsize in3 \\ t1} &
  \bitbox{2}{\scriptsize in3 \\ t0} &
  \bitbox{2}{\scriptsize in2 \\ t3} &
  \bitbox{2}{\scriptsize in2 \\ t2} &
  \bitbox{2}{\scriptsize in2 \\ t1} &
  \bitbox{2}{\scriptsize in2 \\ t0} &
  \bitbox{2}{\scriptsize in1 \\ t3} &
  \bitbox{2}{\scriptsize in1 \\ t2} &
  \bitbox{2}{\scriptsize in1 \\ t1} &
  \bitbox{2}{\scriptsize in1 \\ t0} &
  \bitbox{2}{\scriptsize in0 \\ t3} &
  \bitbox{2}{\scriptsize in0 \\ t2} &
  \bitbox{2}{\scriptsize in0 \\ t1} &
  \bitbox{2}{\scriptsize in0 \\ t0}
\end{bytefield}

\begin{description}
\item[0] Select ADC for one demux path of one input
\item[1] Select noise source for one demux path of one input
\item[2] Select constant 0 for one demux path of one input
\end{description}

Examples:
\begin{description}

\item[0x00000000] Select ADC for all demux paths of all inputs
\item[0x00000001] Select noise source for demux path 0 of input0, select ADC
                  for all other demux paths
\item[0x00000055] Seelct noise source for all demux paths of input 0, select
                  ADC for all other inputs \item[0x55555555] Select noise
                  source for all demux paths of all inputs
\item[0x55000000] Select noise source for all demux paths of input 3, select
                  ADC for all other inputs \item[0xA0000000] Select constant 0
                  for demux paths 2 and 3 of input 3, select ADC for all other
                  inputs
\end{description}
\end{description}

  \subsection{Noise Generators}

\begin{description}

\rwreg{noise/arm}  A 0 to 1 transition of bit~0 of each nybble arms that
input's noise generator.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{19}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in3}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in2}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in1}} &
  \bitbox{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize in0}}
\end{bytefield}

The least significant nybble
corresponds to input0.  A value of 0x0011 will arm the noise generators for
input0 and input1.  A value of 0x1111 will arm all noise generators.

Once a noise generator is armed, it will re-seed starting on the next internal
1~PPS rising edge.  This can be used to synchronously seed noise generators
across multiple devices or within one device.

\filbreak
\rwregn{noise/seed/0}
\rwregn{noise/seed/1}
\rwregn{noise/seed/2}
\rwregs{noise/seed/3} Sets 32~bit seed for noise generators for corresponding
inputs.  Because the inputs are demultiplexed by 4, each noise generator
actually contains two noise generators that each output two independent
normally distributed values each.  The 32~bit seed is actually split into two
16~bits seeds to seed the two contained noise generators.  Using a seed whose
two halves are identical (i.e.\ a multiple of 65537) will result in a signal
that has a lag-2 correlation coefficient of 1 resulting in a non-flat spectrum.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{16}{seed high} &
  \bitbox{16}{seed low}
\end{bytefield}

\end{description}

  \subsection{Delay Core}

The Delay Core delays the input signal and converts it from real to complex
representation.  The delay can range from $0$ to $8191\frac{15}{16}$ samples in
increments of $\frac{1}{16}$ of a sample.  The delay is implemented as a
combination of coarse delay (in units of FPGA clock cycles), fine delay (in
units of ADC sample clock cycles), and sub-sample delay (in units of
$\frac{1}{16}$ an ADC sample clock cycle).  The sub-sample delay is implemented
using a quadrature fractional delay FIR filter that not only does sub sample
delay, but also the conversion to complex form.  Converting to complex form
involves mixing by a local oscillator at $\pm F_s/4$.  The sign of the LO
frequency is user selectable and determines whether the Delay Core's complex
output will consist of the positive or negative frequencies of the real input.
Selecting the negative frequencies will result in a frequency reversal and
conjugation relative the positive frequencies.  See the \verb|sbsel| register
for more details.

\begin{description}

\rwregn{delay0}
\rwregn{delay1}
\rwregn{delay2}
\rwregs{delay3} The 17 \LSbs of these registers specify the "constant" (i.e.
rarely changing) delay to be applied by each input's Delay Core.  The overall
delay that is applied may optionally include an additional time-varying delay
from the delay LUTs (see section TODO).

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{15}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{17}{delay}
\end{bytefield}

The value written into these registers can be computed as

\begin{align*}
register\_value &= 16 \cdot adc\_sample\_delay + 64 &(\mathrm{mod}\:2^{17}) \\
                &= \mathrm{round}(16.384 \cdot ns\_delay) + 64 &(\mathrm{mod}\:2^{17})
\end{align*}

\filbreak
For example, to obtain a delay of 123.456~ns, the value to use would be
computed as

\begin{align*}
register\_value &= \mathrm{round}(16.384 \cdot 123.456) + 64 &(\mathrm{mod}\:2^{17}) \\
                &= 2087
\end{align*}

Because of the 64 sample offset and modulo $2^{17}$ behavior, minimum delay is
obtained with a value of 64, while maximum delay is obtained with a value of
63.

\rwreg{sbsel} The \verb|sbsel| (sideband select) register specifies whether the
complex output will consist of the positive or negative frequencies of the real
input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{16}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb3}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb2}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb1}} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sb0}}
\end{bytefield}

Each of the four \LSns (i.e. hex digits) of \verb|sbsel| corresponds
one input.  The \LSn specifies the sideband selection for input 0.  A value of
0 selects the positive frequencies; a value of 1 selects the negative
frequencies.  Writing 0x0100 will select positive frequencies for inputs~0,1,3
and negative frequencies for input2.

\end{description}

  \subsection{Phase Rotation}

After the Delay Core's conversion to complex, the signal passes through a phase
rotator.  The amount of phase rotation applied is a combination of the phase
offset introduced by fine delay, the phase value specified in the input's
\verb|phaseN| register, and the 0/90/180/270 degree phase switching specified
by the input's current phase switching state.  The phase offset introduced by
fine delay is automatically compensated; no user input is required.  The
\verb|phaseN| registers are described here and the phase switching states are
described in a separate subsection.

\begin{description}

\rwregn{phase0}
\rwregn{phase1}
\rwregn{phase2}
\rwregs{phase3} These registers specify the amount of user-specified "constant"
(i.e. rarely changing) phase rotation to be applied to each input's complex
signal.  The overall phase offset that is applied may optionally include an
additional time-varying phase offset from the phase LUTs (see section TODO).
These phase offsets are independent phase switching, which is handled
separately (see section TODO).

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{20}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{12}{phase}
\end{bytefield}

Because only the 12 least significant bits of these registers are used for one
complete turn in phase, the resolution is $\frac{2 \pi}{2^{12}}$ radians per
step or $\frac{360}{2^{12}}$ degrees per step (i.e. approximately 88
millidegrees per step).

The value written into these registers can be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(
                      phase\_radians \cdot \frac{2^{12}}{2 \pi}
                    \right) \\
                &   \:\text{or} \\
register\_value &=  \mathrm{round}\left(
                      phase\_degrees \cdot \frac{2^{12}}{360}
                    \right)
\end{align*}

For example, to phase
rotate a given input by 30 degrees, the value to use would be computed as

\begin{align*}
register\_value &=  \mathrm{round}\left(30 \cdot \frac{2^{12}}{360}\right) \\
                &=  341
\end{align*}

\end{description}

  \subsection{Phase Switching}

As mentioned elsewhere, the design supports both SMA and CARMA phase switching
schemes.  Both observatories use nested Walsh functions whereby the 180 degree
phase switching cycle completes once per 90 degree phase switching state.  The
Wash functions themselves are stored in two shared block RAM lookup tables.
One table is for the 180 degree phase switch cycle and the other table is for
the 90 degree phase switching cycle.  Each entry (i.e. row) in a Walsh table is
32 bits wide.  Each bit (i.e. column) corresponds to a given Walsh function.
Each input uses a user specified column for both the 90 and 180 degree Walsh
functions.  To provide the simplest and most versatile interface, the Walsh
tables are stored in unrolled form.

\begin{description}

\rwreg{walsh/syncsel} This register is used to select the timing of the Walsh functions.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

A value of 0 selects the internal 1024~PPS (for CARMA).  A value of 1 selects
the internal HB signal (for SMA).

\filbreak
\rwreg{walsh/colsel} This register is used to specify which columns (i.e. bits)
of the Walsh tables to use for each input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox[ltb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in3 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in2 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in1 \\ colsel} &
  \bitbox[tb]{3}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{5}{\scriptsize in0 \\ colsel}
\end{bytefield}

Each input is controlled by one byte of this register.  Input~0 uses the \LSB
of this register.  Only the five \LSbs of each byte are used to select
columns~0 through 31.  Column~0 is the \MSb of the 32~bit Walsh table entries.

\rwreg{walsh/sign90}
The \LSb of the \verb|walsh/sign90| register specifies the sign of 90 degree phase
switch in the upper sideband.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize s90}}
\end{bytefield}

The signal and its 90 degree phase switching may be conjugated multiple times
before the 90 degree phase switching gets undone (for the sky upper sideband)
in the phase rotator.  The conjugations are caused by lower sideband
downconversions, including sampling the second (or any even) Nyquist zone and
setting \verb|sbsel=1|, both of which are essentially lower sideband down
conversions.  If the total number of conjugations is odd, then the final signal
and its 90 degree phase switching will be conjugated, which will require
rotating the phase in the opposite direction as compared to the original,
non-conjugated signal.

\begin{description}
\item[0] The analog 90 degree phase switching is assumed to be a +90 degree
         phase rotation in the USB and a -90 degree phase rotation in the LSB.
         The complex signal is phase rotated by -90 degrees, which rotates the
         USB to 0 degrees and the LSB to 180 degrees.

\item[1] The analog 90 degree phase switching is assumed to be a -90 degree
         phase rotation in the USB and a +90 degree phase rotation in the LSB.
         The complex signal is phase rotated by +90 degrees, which rotates the
         USB to 0 degrees and the LSB to 180 degrees.
\end{description}

\bramn{walsh/table/90}
\brams{walsh/table/180} These shared block RAMs must be programmed with the
unrolled Walsh tables.  Each table (i.e. BRAM) is 2048 entries long.  Each
entry is 32~bit wide.  Each bit position corresponds to a column of a Walsh
table.  The \MSb of each 32-bit entry corresponds to column~0 of the (up to)
32~column Walsh table.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{1}{\rotatebox{90}{\scriptsize col0}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col1}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col2}} &
  \bitbox[blt]{3}{\dots} &
  \bitbox[bt]{8}{} &
  \bitbox[bt]{4}{\dots} &
  \bitbox[bt]{8}{} &
  \bitbox[brt]{3}{\dots} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col29}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col30}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize col31}}
\end{bytefield}

Table \verb|walsh/table/90| is for the 90 degree phase switching states.\\
Table \verb|walsh/table/180| is for the 180 degree phase switching states.

The Walsh tables are addressed by a counter that increments every phase
switching state (i.e. every 1024~PPS for CARMA; every HB for SMA) and is reset
at the end of every Walsh function cycle (i.e.  every 1~PPS for CARMA and every
SOWF for SMA).  Only the first N entries need to be populated, where N is the
number of phase switching states per complete phase switching cycle (i.e. 1024
for CARMA, 64 for SMA).

\end{description}

  \subsection{Look-Up Tables}

The delay and phase offsets required to properly sum the signals together
change over time.  Often these changes must be applied more frequently and with
greater timing precision (e.g. on 0/180 degree phase switch boundaries) than is
possible over the limited interface of the iBobs.  To address this problem, the
design provides both delay and phase lookup tables (LUTs) which are stepped
through at a predetermined rate to provide precisely timed delay and phase
tracking.  The use of these LUTs is optional.  A custom command,
\verb|loadlut|, has been added to the iBob interface to facilitate rapid
pre-population of the delay and phase lookup tables, thereby avoiding the
interface performance limitations of the iBob.  The outputs of the LUTs are
registered on every address increment so changing the value of the currently
addressed LUT location will not change the current overall delay or phase
offset.


\begin{description}

\rwreg{lut/arm} A rising edge of the \LSb of this register synchronizes the LUT
address counter with the start of the next Walsh cycle.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}} &
\end{bytefield}

The delay and phase LUTs are addressed by a common counter that increments
after every 32 (CARMA) or 64 (SMA) Walsh states, depending on the setting of
the \verb|walsh/syncsel| register.  The LUT address counter is synchronized
with the start of the next complete Walsh cycle after a rising edge of the \LSb
of the \verb|lut/arm| register.  Knowing the absolute time of LUT address
synchronization and the rate at which the LUT address increments, the
controlling software can compute the LUT addresses at which to store upcoming
delay and phase tracking values.

\roreg{lut/addr} The current value of the 11-bit LUT address counter.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{21}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{11}{LUT address} &
\end{bytefield}

\filbreak
\rwreg{lut/enable} Controls whether the LUT output values are included in the
overall delay and phase offsets applied to the input signals.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize en}} &
\end{bytefield}

When the \LSb of this register is set to 1, the LUT values will be added to
the corresponding \verb|delayN| and \verb|phaseN| offsets applied to the input
signals, otherwise they will not be added.  Note that the LUT address counter
always increments regardless of whether the LUT outputs are enabled.

\bramn{lut/delay/0}
\bramn{lut/delay/1}
\bramn{lut/delay/2}
\brams{lut/delay/3} These shared block RAMs contain the delay LUT values for
each of the four inputs.  Each LUT is 2048 entries long.  The 18 \LSbs of each
32-bit entry is treated as a two's complement value with four fractional bits
providing a delay LUT offset ranging from $-8192\frac{0}{16}$ to
$+8191\frac{15}{16}$~ADC~samples.  This allows one to set the "constant"
\verb|delayN| offset registers to a midrange value and then use the delay LUTs
to go plus or minus the midrange values.  When \verb|lut/enable| is 1, the
overall delay (in units of $\frac{1}{16}$ of an ADC sample) is given by
\begin{equation*}
\mathtt{delay}N + \mathtt{lut\_delay\_}N\mathtt{[lut\_addr]} \pmod{2^{17}}
\end{equation*}
The result will always be treated as a positive value, so care must be taken to
avoid unintended overflow/wrapping of the 17-bit unsigned input range of the
Delay Core.

\bramn{lut/phase/0}
\bramn{lut/phase/1}
\bramn{lut/phase/2}
\brams{lut/phase/3} These shared block RAMs contain the phase LUT values for
each of the four inputs.  Each LUT is 2048 entries long.  The 12 \LSbs of each
32-bit entry is treated as an unsigned phase value in units of $\frac{2
\pi}{2^{12}}$~radians.  When \verb|lut/enable| is 1, the overall phase offset,
in units of $\frac{2 \pi}{2^{12}}$ radians, is given by
\begin{equation*}
\mathtt{phase}N + \mathtt{lut\_phase\_}N\mathtt{[lut\_addr]} \pmod{2^{12}}
\end{equation*}

\filbreak
\tinysh{loadlut} Over time intervals of a minute or less, the delay and phase
variations that remain in the sampled IF signal can be approximated with
negligible error by a linear function.  The \verb|loadlut| command can be used
to pre-populate a range of consecutive locations within the delay and phase
LUTs with such a linear function.  The syntax of the \verb|loadlut| command is:
\begin{verbatim}
loadlut LUT_NAME START_ADDR START_VALUE STEP COUNT SHIFT
\end{verbatim}
Where:
\begin{description}
\item[$\mathtt{LUT\_NAME}$] is the name of the LUT to load (e.g.
\verb|lut/delay/0|).
\item[$\mathtt{START\_ADDR}$] is the address at which the first value will be
stored.
\item[$\mathtt{START\_VALUE}$] is the first value to be stored.
\item[$\mathtt{STEP}$] is the increment between each successive value.
\item[$\mathtt{COUNT}$] is the total number of values to store.
\item[$\mathtt{SHIFT}$] is the number of bits to right shift the value before
storing.
\end{description}

The LUT addresses are always treated modulo the LUT size.  This "wrap around"
behavior simplifies pre-populating a series of LUT entries that would otherwise
overrun the end of the LUT.

The \verb|SHIFT| parameter allows \verb|START_VALUE| and \verb|STEP| to be
given with higher precision than that of the LUT itself.

The values and locations at which they are stored are given by
\begin{equation*}
\mathtt{LUT\_NAME}[(\mathtt{START\_ADDR} + n) \% 2048]
= (\mathtt{START\_VALUE} + n \cdot \mathtt{STEP}) \gg \mathtt{SHIFT} 
\end{equation*}
where $n$ ranges from 0 to $\mathtt{COUNT}-1$.

\end{description}

  \subsection{2-Bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  The calibration correlator gets 2~bit data
(at the ADC sample rate) from all inputs.  The quantization to 2~bits is
controlled by user specified threshold values.  The 2~bit coding represents
four distinct values: -3, -1, +1, +3.

\begin{description}

\rwregn{quant/thresh0}
\rwregn{quant/thresh1}
\rwregn{quant/thresh2}
\rwregs{quant/thresh3}  These registers set the thresholding level used for
quantizing each input to 2~bits.  When using the digital noise sources, 16 is a
suitable value.  For CARMA IFs, 22 is a suitable value.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{25}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{7}{threshold}
\end{bytefield}

\filbreak
The quantized value for a given input value of $x$ and unsigned 7~bit threshold
value $thresh$ is determined according to the equations shown here.  Note that
the output value for a zero valued input alternates between -1 and +1.

\begin{align*}
           &\,x <= -thresh &\Rightarrow -3 \\
-thresh <  &\,x < 0        &\Rightarrow -1 \\
           &\,x = 0        &\Rightarrow \pm1 \\
      0 <  &\,x < thresh   &\Rightarrow +1 \\
 thresh <= &\,x            &\Rightarrow +3
\end{align*}

When using a digital noise source as an input, a threshold value of 16 results
in a $\left\{\frac{1}{6}, \frac{2}{6}, \frac{2}{6}, \frac{1}{6}\right\}$
distribution in the 2~bit quantized values.

\end{description}

  \subsection{8-bit Data Path}

After the Delay Core and Phase Rotation, the signals are sent to the
calibration correlator and the DBE.  Before being sent to the DBE, the four
8~bit input signals are summed together then scaled and rounded back to 8~bits.
Before the sum each input signal is multiplied by a gain factor.  This gain
factor is intended to weight the inputs according to system temperature, but
thus far they have been used only to scale all inputs equally or to zero out an
input to exclude it from the sum.

The sum is scaled by~$\frac{1}{2}$ or~$\frac{1}{4}$ (see the
\verb|adder/shift| register) and then rounded to 8~bits before being sent over
the XAUI links to the Digital Back End (DBE).  The unbiased rounding mode known
as "round-to-even" is used.  Scaling by~$\frac{1}{2}$ and rounding to even will
result in three times as many even values as odd values, assuming the \LSb is
uniformly distributed.  Scaling by~$\frac{1}{4}$ and rounding to even will
result in~$\frac{5}{3}$ times as many even values as odd values, assuming the
two \LSbs are uniformly distributed.

\begin{description}

\rwregn{gain0}
\rwregn{gain1}
\rwregn{gain2}
\rwregs{gain3} These registers control the gain factor for each input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{24}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{8}{gain}
\end{bytefield}

Only the 8 \LSbs are used.  They are currently interpreted as an unsigned
number with 7 fractional bits.  Thus, the range of gain values that can be
applied to each input is~$0$ to~$1\frac{127}{128}$.

\filbreak
\rwreg{adder/shift} This register select the scaling factor applied to the sum
before re-quantizing to 8~bits.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

Set this to~0 to scale the sum by~$\frac{1}{2}$ (e.g. for independent noise
dominated inputs).  Set this to~1 to scale the sum by~$\frac{1}{4}$ (e.g. for
coherent inputs).  The current gateware is setup to wrap instead of saturate
when scaling by~$\frac{1}{4}$.  Future gateware versions may change this
arguably erroneous behavior. 

\end{description}

  \subsection{XAUI}

The sum of the phased inputs is sent to the DBE via the XAUI0 connector.  The
2-bit quantized inputs are sent to the calibration correlator via the XAUI1
connector.  XAUI data transmission is always enabled whenever the corresponding
XAUI link is up.

\begin{description}

\rwreg{start\_xaui} This register is deprecated.  It used to control
transmission over the XAUI links and generation of the clock that is sent to
the BEE2 calibration correlator.  These functions are now enabled
automatically.  They do not require, and function better without, user
intervention.  This register exists solely to maintain backwards compatibility
with existing software.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{32}{\color[gray]{0.75}\rule{\width}{\height}} &
\end{bytefield}

\roregn{xaui\_0/rx\_linkdown}
\roregs{xaui\_1/rx\_linkdown} A value of 1 indicates a ``link down'' status on
the (unused) receive side of the indicated XAUI connection, which strongly
implies a similar status for its transmit side.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ldn}}
\end{bytefield}

\end{description}

  \subsection{Front Panel SMA Output}

\begin{description}

\rwreg{smasel} Selects which signal to output over the front panel \verb|SMA0|
connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}

\item[0] Outputs a 128~MHz square wave (50\% duty cycle).

\item[1] Outputs a constant 0.

\end{description}

\filbreak
\rwreg{monsel} Selects which signal to output over the front panel \verb|SMA1|
connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{3}{sel}
\end{bytefield}

\begin{description}

\item[0] Outputs a constant 0.

\item[1] Outputs the internal 1024~PPS signal.

\item[2] Outputs the internal Heartbeat (HB) signal.

\item[3] Outputs the internal Start of Walsh Frame (SOWF) signal.

\item[4] Outputs the internal 1~PPS signal.

\item[5] Outputs the sampled sync0 signal (from ADC0)

\item[6] Outputs the sampled sync1 signal (from ADC1)

\end{description}

\end{description}

\filbreak
  \subsection{Front Panel LEDs}
\begin{description}
\item[LED0] Not used.
\item[LED1] Not used.
\item[LED2] Briefly blinks on each rising edge of the sync0 input.
\item[LED3] Not used.
\item[LED4] Not used.
\item[LED5] Not used.
\item[LED6] Not used.
\item[LED7] Not used.
\item[LED8] Indicates FPGA is configured (non-functional on some iBobs).
\end{description}

\newpage
\section{BEE2 Calibration Correlator}

This section documents the bee2\_complex\_corr\_floating\_2011\_Feb\_17\_2045
design.

The bee2\_complex\_corr design receives 2+2 bit samples (i.e. 2 real bits and 2
imaginary bits per sample) from a total of eight inputs (two IPAs).  It cross
correlates one of these signals (user selectable) with itself and the other
seven inputs.  Each of the 7 cross-correlations and 1 auto-correlation consists
of 16 lags (-8 to +7).  In addition to the data samples, the design also
receives sync and 90 degree phase state information from the IPAs over the XAUI
links' out of band channel.  This allows the correlator to perform sideband
separation, producing both upper and lower sideband lag spectra for each
baseline.

\subsection{Input numbering}

The four signals arriving over XAUI1 are considered to be input0 through
input3.  The four signals arriving over XAUI0 are considered to be input4
through input7.  Note that the higher number XAUI port contains the lower
number inputs and vice versa.

\subsection{Input values}

The four distinct values of the 2~bit samples represent signal values of -3,
-1, +1, and +3.  The threshold registers in the ibob\_phased\_array\_2k design
should be set such that approximately 1/6 of the samples are -3, 1/3 are -1,
1/3 are +1, and 1/6 are +3.  With this distribution, the lag~0 auto-correlation
will have a mean of 11/3 and a variance of 128/9.

\subsection{Integration limit}

With an input signal distribution as described above, a one second (i.e.
1024\e6 samples) integration will have a mean of $\frac{11}{3}\cdot1024\e6$ and
a variance of $\frac{128}{8}\cdot1024\e6$.  This integrated mean is more
3.75\e9, which is well over 2.1475\e9, the maximum value supported by a signed
32-bit value.  To delay overflowing, the BRAM vector accumulators are 36 bits
wide.  Their output values are rounded to 32 bits wide before writing them into
shared BRAMs.

Another factor of 2 savings is obtained by dropping the LSB of the
sub-integrations.  The input values are all odd so their products will all be
odd too.  Since an even number of odd products are integrated before the BRAM
vector accumulators, the \LSb will always be 0, so it is dropped without any
loss of precision.

These two techniques result in scaling down the integrations by a factor of 32.
This allows integrations as long as 18 seconds without overflowing the 36 bit
vector accumulators (or the 32 bit shared BRAMs).  This limit is only for
highly correlated signals such as the lag~0 auto-correlation or coherent noise
sources.  Inputs dominated by independent noise (e.g. astronomical cross
correlations) have far higher maximum integration times.

\subsection{XAUI Alignment and Monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
correlation.  The design will automatically align the two XAUI streams and, if
ever necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize del}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize mon}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize cor}}
\end{bytefield}

Setting bit~0 (cor) to 1 will reset the XAUI core itself (rarely needed).
Setting bit~1 (mon) to 1 will reset the counters associated with XAUI
monitoring.  Setting bit~2 (del) to 1 will reset the registers that capture the
relative delays of the two XAUI links.  These bits are level sensitive, not
edge sensitive, so they must be cleared to take the associated circuitry out of
reset.

\roregn{xaui0/linkdown\_cnt}
\roregs{xaui1/linkdown\_cnt} Indicates how many times the link has gone down
(i.e. transitioned from up to down).  Under normal operations this register
should read~0, though it may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period}
\roregs{xaui1/period}
Indicates the number of FPGA (256 MHz) clock cycles between the most recently
received 1024~PPS pulse and the previous one.  Under normal operations, this
register should read~250000.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period\_err}
\roregn{xaui1/period\_err}
\roregn{xaui0/period\_err\_cnt}
\roregs{xaui1/period\_err\_cnt}
The XAUI monitoring logic constantly monitors the number of FPGA cycles between
1024~PPS pulses.  It counts the number of period errors and remembers the most
recent erroneous period value.  The \verb|xauiN/period_err_cnt| registers
indicate the total number of erroneous periods detected.  Under normal
operations, these registers should read~0.  The \verb|xauiN/period_err|
registers indicate the most recent erroneous period value.  Under normal
operations, these registers should read~0 (i.e. no erroneous period measured).
These registers are reset by bit~1 of the \verb|xaui_rst| register.

\filbreak
\roregn{xaui0/sync\_cnt}
\roregs{xaui1/sync\_cnt} This register indicates the total number of 1024~PPS
pulses received.  Since it is a 32~bit counter, it will roll over approximately
every 48.5 days.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/rx\_empty\_cnt}
\roregs{xaui1/rx\_empty\_cnt} Indicates how many times the XAUI FIFO has
underflowed.  Under normal operations this register should read~0, though it
may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/almost\_full}
\roregs{xaui1/almost\_full} Indicates the current state of the XAUI's
\verb|almost_full| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize af}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/rx\_linkdown}
\roregs{xaui1/rx\_linkdown} Indicates the current state of the XAUI's
\verb|link_down| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ldn}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/valid}
\roregs{xaui1/valid} The two \LSbs of this register contain the current and
previous value of the XAUI block's \verb|valid| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize val}
\end{bytefield}

Since this status bit should toggle every clock cycle, this register should
read~1 or~2 under normal operation.

\filbreak
\roregn{xaui\_aligner/delay0}
\roregs{xaui\_aligner/delay1} These registers indicate the number of cycles
from the stream's incoming 1024~PPS and the reference 1024~PPS.  Since the
reference 1024~PPS is just a 32 cycle delayed version of XAUI0's 1024~PPS,
\verb|xaui_aligner/delay0| should always read 32.  Under normal operations,
\verb|xaui_aligner/delay1| should be $32\pm32$, but usually it will be
$32\pm4$.
\end{description}

\subsection{Synchronization and Integration}

In order to perform sideband separation, the correlator must integrate for an
integral number of Walsh cycles.  The registers used to control and monitor
synchronization of the integrations are described here.

\begin{description}

\rwreg{syncsel} This register selects the sync signal used to drive integration
timing.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize sel}
\end{bytefield}

The sync signal selection determines the units of the \verb|integ_time|
register.  The four choices are:

\begin{description}
\item[0] Use the 1024~PPS signal to define the integration units.
\item[1] Use the HB signal to define the integration units.
\item[2] Use the SOWF signal to define the integration units.
\item[3] Use the 1~PPS signal to define the integration units.
\end{description}

\rwreg{integ\_time} This register sets the integration time in units of the
sync signal selected via the \verb|syncsel| register.  Changing the value of
this register resets the correlator's internals as well as the
\verb|integ_cnt| register.

\roreg{integ\_cnt} This register simply counts the number of integrations that
have completed.  When this register increments, a new integration is ready to
be read.  Changing the \verb|integ_time| register resets this register.

\roreg{sample\_cnt} The correlator always integrates in multiples of 32 samples
(since there are 16 lags per baseline and 2 samples per FPGA clock cycle).  If
the selected integration unit (see \verb|syncsel|) is not commensurate with 32
samples (e.g. the Heartbeat signal) then the number of samples per integration
can vary from integration to integration.  This register provides the number of
32-sample sub-integrations in the most recently completed integration.  It can
be used to properly average the data.  Since the integrated values are
pre-divided by 32 in the FPGA, the output values can be divided by this
register value directly to get the average of the integrated products.

\roreg{subint\_cnt} This register indicates how far along the current
integration is.  It is in units of the sync signal selected via the
\verb|syncsel| register.  It counts from 0 to $integ\_time - 1$, then starts
over.

\rwreg{refant} This register selects the reference \emph{input} (NB: \emph{not}
antenna) that is common to all eight of the computed baselines, including the
auto-correlation ``baseline''.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{3}{\scriptsize ref\\ant}
\end{bytefield}

\bramn{rx0/usb\_real}
\bramn{rx0/usb\_imag}
\bramn{rx0/lsb\_real}
\bramn{rx0/lsb\_imag}
\bramn{$\vdots$}
\bramn{rx7/usb\_real}
\bramn{rx7/usb\_imag}
\bramn{rx7/lsb\_real}
\brams{rx7/lsb\_imag} These shared BRAMs hold the integrated 16~lag spectra for
the upper and lower sidebands of each of the eight computed baselines.  The
\verb|rx0/usb_real| BRAM contains the integrated real component of the upper
sideband (USB) of input0 times the complex conjugate of the reference input.
The \verb|rx7/lsb_imag| BRAM contains the integrated imaginary component of the
lower sideband (USB) of input7 times the complex conjugate of the reference
input.  Note that some baselines can have a conjugation convention that differs
from MIRIAD's conjugation convention depending on which input is chosen to be
the reference input and which antennas are connected to which inputs.  The 16
lags are stored from lag~-8 to lag~+7.

\roregn{phsw\_bal/0}
\roregn{$\vdots$}
\roregs{phsw\_bal/7} These registers indicate the \emph{phase switching
balance} for the most recently completed integration for each of the baselines.
During the integration, a counter (accumulator, really) counts +1 for each
sample where the inputs were in the same 90 degree phase switch state and -1
for each sample where the inputs were in different 90 degree phase switch
states.  For optimum sideband separation, the inputs should have an equal
number of samples while in the same and different 90 degree phase switching
states, so ideally this output should read zero.  If it is positive, then there
that many more samples with the same 90 degree phase switch state.  If it is
negative, then there that many more samples with different 90 degree phase
switch state.  Note that the count is in FPGA cycles, which is half the number
of data samples (due to demux-by-2 data).

\roreg{uptime} The uptime register is a 32~bit counter that counts seconds
since the FPGA started running.  It cannot be reset (other than reprogramming
the FPGA) and is not synchronized with any other 1 PPS source.

\rwreg{wdelay} This register adjusts the delay applied to the Walsh inputs to
align them with the data out from the correlator.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{26}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{6}{\scriptsize wdelay}
\end{bytefield}

The total delay needed is calculated to be 65, but to accommodate errors in the
calculation, a variable delay element is provided.  The range of valid values
for this register are 0 to 63.  Some of the estimated delay is built in to the
design already.  The estimated value required for this register is 32.  Once a
good value is determined empirically, it will be hard-coded into the design and
this register will be removed.

\end{description}

\subsection{Snapshot Data}

The design includes a snapshot block that can be used to capture some input
samples to help set the upstream threshold registers and other diagnostic
purposes.

\begin{description}

\rwreg{snap/ctrl} This register controls the snapshot block.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize trg}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize en}}
\end{bytefield}

A 0 to 1 transition of bit~0 (en) enables a snapshot sequence.  Once the
snapshot sequence is enabled, the data capture will begin immediately if bit~1
(trg) is 1 or on the next selected sync pulse (see \verb|syncsel|) if bit~1
(trg) is 0.

\roreg{snap/addr} During data capture, this register provides the address
within the shared BRAMs to which the data are being written.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{21}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{11}{snap address}
\end{bytefield}

When the data capture is complete, the address holds at the final value of
2047.  The data capture completes in 8~\textmu s, so this register is useful
primarily when the data capture is setup to begin on the next sync pulse
(otherwise it is unlikely that any value other than 2047 will be observed in
this register).

\filbreak
\bramn{snap/in0123}
\brams{snap/in4567} These shared BRAMs hold the snapshot data.  Each BRAM is
2048 words deep and stores data for the four inputs implied by its name.
Within a BRAM, each 32~bit word stores two complex samples for all four inputs.
The \MSB holds two complex samples of the BRAM's lowest numbered input; the
\LSB holds two complex samples of the BRAM's highest numbered input.  Within a
byte, the two \MSbs represent the real component of the first (in time) of the
byte's two complex samples.  Thus, each shared BRAM can hold 4096 complex
samples for four inputs.  The storage format for the first word (BRAM address
0) of \verb|snap/in0123| is shown in the following diagram (\verb|snap/in4567|
is similar).

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{2}{\scriptsize in0 \\ re0} &
  \bitbox{2}{\scriptsize in0 \\ im0} &
  \bitbox{2}{\scriptsize in0 \\ re1} &
  \bitbox{2}{\scriptsize in0 \\ im1} &
  \bitbox{2}{\scriptsize in1 \\ re0} &
  \bitbox{2}{\scriptsize in1 \\ im0} &
  \bitbox{2}{\scriptsize in1 \\ re1} &
  \bitbox{2}{\scriptsize in1 \\ im1} &
  \bitbox{2}{\scriptsize in2 \\ re0} &
  \bitbox{2}{\scriptsize in2 \\ im0} &
  \bitbox{2}{\scriptsize in2 \\ re1} &
  \bitbox{2}{\scriptsize in2 \\ im1} &
  \bitbox{2}{\scriptsize in3 \\ re0} &
  \bitbox{2}{\scriptsize in3 \\ im0} &
  \bitbox{2}{\scriptsize in3 \\ re1} &
  \bitbox{2}{\scriptsize in3 \\ im1}
\end{bytefield}

\end{description}

\newpage
\section{XAUI-based Digital Back End (DBE)}

This section documents the dbe\_xaui\_corr\_2012\_Feb\_02\_2334 design.

The dbe\_xaui\_corr design receives two phased sums of four inputs each (aka
partial sums) from two different iBob Phased Array Processors via XAUI.  It
time-aligns these two incoming signals, sums them (producing the final sum),
and then processes/formats the summed signal for recording to the VLBI data
recorder via the iBob's front panel VSI connector.

The design also provides a number of additional features to facilitate system
verification and other engineering purposes.  Most notable among the additional
features are:

\begin{itemize}
\item Single ADC input for a so-called "comparison antenna" with optional
fringe tracking
\item Digial noise source compatible with the ones in the iBob Phased Array
Processor
\item Delay Core compatible with the one in the iBob Processor Array Processor
\item Single baseline 16-lag correlator to compare various signals
\item Snapshot buffer for capturing samples of various signals
\item Versatile signal path routing
\end{itemize}

During VLBI observations, the DBE is controlled by the data recorder via the
iBobs RS-232 port.  While all the design features are accessible over both
Ethernet and serial interfaces, the data recorder typically accesses a fairly
minimal subset of registers and Block RAMs.

  \subsection{Synchronization}

The VLBI data recorder requires a 1~PPS signal.  In order to provide this, the
DBE must be provided an external 1~PPS sync signal (via the ADC0 board) with
which it synchronizes internally generated 1~PPS and 1024~PPS signals (via the
\verb|arm1pps| command).

The parital sums are aligned via the 1024~PPS signals that are received over
their XAUI out-of-band signals.  Since their upper sidebands are already
de-Walshed, the partial and final sums have no need for Walsh timing in the
DBE.  Currently the comparison antenna ADC input is assumed to have no phase
switching so it, too, has no need for Walsh timing in the DBE.

\begin{description}

\roreg{onepps\_sync/diff} This register captures the difference, in FPGA clock
cycles, between the external 1~PPS signal and the internally generated 1~PPS
signal.  Normally this register will read 0, but since the external 1~PPS
signal is not synchronous with the ADC sample clock, values of 1 or
256,000,000 are also acceptable.  Other values indicate a problem.

\roreg{onepps\_sync/ext\_cnt} This register contains the number of rising edges
seen on the external 1~PPS signal since the last re-arming of the internal
1~PPS signal.

\roreg{onepps\_sync/ext\_period} This register contains the number of FPGA clock
cycles between the two most recent rising edges seen on the external 1~PPS
signal.  It should read 256,000,000 $\pm$ 1.

\rwreg{onepps\_sync/arm1pps} A 0 to 1 transition of bit~0 of this register will
arm the internal 1~PPS generator to re-synchronize with the next rising edge of
the selected sync pulse.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\roreg{onepps\_sync/arm1pps\_ack} A 1 to 0 transition of bit~0 of
\verb|onepps_sync/arm1pps| clears (i.e. sets to zero) this register.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ack}}
\end{bytefield}

Bit~0 of this register is set to 1 on the rising edge of the next sync pulse
that re-synchronizes the internal 1~PPS generator.  This can be used to verify
that the internal 1~PPS generator did indeed re-synchronize after being armed.
This register is not often used directly since (re-)arming is normally done via
the \verb|arm1pps| command.

\end{description}

  \subsection{XAUI Alignment and Monitoring}

The alignment of the two incoming XAUI streams is critical to achieving proper
summing.  The design will automatically align the two XAUI streams and, if ever
necessary, re-align them at the next 1024~PPS.  This ensures that the two
streams are never misaligned for more than 1/1024 of a second.  Additionally,
the out-of-band sync signals sent over the XAUI link are monitored for any
anomalous behavior.  The registers involved in the XAUI alignment and
monitoring are described here.

\begin{description}
\rwreg{xaui\_rst}  Resets various parts of XAUI related logic.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{29}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize del}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize mon}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize cor}}
\end{bytefield}

Setting bit~0 (cor) to 1 will reset the XAUI core itself (rarely needed).
Setting bit~1 (mon) to 1 will reset the counters associated with XAUI
monitoring.  Setting bit~2 (del) to 1 will reset the registers that capture the
relative delays of the two XAUI links.  These bits are level sensitive, not
edge sensitive, so they must be cleared to take the associated circuitry out of
reset.

\roregn{xaui0/linkdown\_cnt}
\roregs{xaui1/linkdown\_cnt} Indicates how many times the link has gone down
(i.e. transitioned from up to down).  Under normal operations this register
should read~0, though it may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period}
\roregs{xaui1/period}
Indicates the number of FPGA (256 MHz) clock cycles between the most recently
received 1024~PPS pulse and the previous one.  Under normal operations, this
register should read~250000.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/period\_err}
\roregn{xaui1/period\_err}
\roregn{xaui0/period\_err\_cnt}
\roregs{xaui1/period\_err\_cnt}
The XAUI monitoring logic constantly monitors the number of FPGA cycles between
1024~PPS pulses.  It counts the number of period errors and remembers the most
recent erroneous period value.  The \verb|xauiN/period_err_cnt| registers
indicate the total number of erroneous periods detected.  Under normal
operations, these registers should read~0.  The \verb|xauiN/period_err|
registers indicate the most recent erroneous period value.  Under normal
operations, these registers should read~0 (i.e. no erroneous period measured).
These registers are reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/sync\_cnt}
\roregs{xaui1/sync\_cnt} This register indicates the total number of 1024~PPS
pulses received.  Since it is a 32~bit counter, it will roll over approximately
every 48.5 days.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/rx\_empty\_cnt}
\roregs{xaui1/rx\_empty\_cnt} Indicates how many times the XAUI FIFO has
underflowed.  Under normal operations this register should read~0, though it
may increment some during system startup.
Reset by bit~1 of the \verb|xaui_rst| register.

\roregn{xaui0/almost\_full}
\roregs{xaui1/almost\_full} Indicates the current state of the XAUI's
\verb|almost_full| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize af}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/rx\_linkdown}
\roregs{xaui1/rx\_linkdown} Indicates the current state of the XAUI's
\verb|link_down| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize ldn}}
\end{bytefield}

Under normal operation, this register should read~0.

\roregn{xaui0/valid}
\roregs{xaui1/valid} The two \LSbs of this register contain the current and
previous value of the XAUI block's \verb|valid| status bit.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize val}
\end{bytefield}

Since this status bit should toggle every clock cycle, this register should
read~1 or~2 under normal operation.

\roregn{xaui\_aligner/delay0}
\roregs{xaui\_aligner/delay1} These registers indicate the number of cycles
from the stream's incoming 1024~PPS and the reference 1024~PPS.  Since the
reference 1024~PPS is just a 32 cycle delayed version of XAUI0's 1024~PPS,
\verb|xaui_aligner/delay0| should always read 32.  Under normal operations,
\verb|xaui_aligner/delay1| should be $32\pm32$, but usually it will be
$32\pm4$.

\rwreg{delay\_adj} Delays the internal 1024~PPS signal so that it will align
with the incoming 1024~PPS signals within the window of the alignment buffer's
64 sample window.  This register is initialized to 7 at FPGA startup.

\end{description}

  \subsection{Signal Path Routing}

The signal path routing options control the selection of the comparison input,
the output to the data recorder, and the inputs to the single baseline
correlator and snap block.  The inputs to the single baseline correlator are
independent from the output to the data recorder.  This allows, for examle,
recording the final sum while correlating the two partial sums to verify that
they are being properly aligned by the XAUI alignment logic.

\begin{description}

\filbreak
\rwreg{compsel} Selects the comparison input signal.  Either the ADC0 input or
DBE's digital noise source can be the comparison input signal that passes
through the Delay Core.  Uses one bit per time sample (i.e. demux path), but
most often the same input, either ADC0 or digial noise source, will be selected
for all four demux paths.  The Delay Core transforms the comparison input
signal from real demux-by-4 to complex demux-by-2.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{28}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel3}}
  \bitbox{1}{\rotatebox{90}{\scriptsize sel2}}
  \bitbox{1}{\rotatebox{90}{\scriptsize sel1}}
  \bitbox{1}{\rotatebox{90}{\scriptsize sel0}}
\end{bytefield}

\begin{description}
\item[0] Selects the ADC0 input for the given demux path.
\item[1] Selects the digital noise source for the given demux path.
\end{description}

\rwreg{vsisel} Selects the signal to send to the data recorder via the VSI
interface.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Sends the final sum to the data recorder.
\item[1] Sends the comparison input to the data recorder.  See the
\verb|compsel| register.
\item[2] Sends the partial sum from XAUI 0 to the data recorder.
\item[3] Sends the partial sum from XAUI 1 to the data recorder.
\end{description}

\rwregn{corrsel0}
\rwregs{corrsel1} Selects the input signals to the single baseline correlator.
\verb|corrsel0| selects the correlator's first input signal; \verb|corrsel1|
selects the second.  The first input to the correlator is also the input to the
snap block.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

\begin{description}
\item[0] Selects the final sum.
\item[1] Selects the comparison input.  See the \verb|compsel| register.
\item[2] Selects the partial sum from XAUI 0.
\item[3] Selects the partial sum from XAUI 1.
\end{description}


\end{description}

\filbreak
  \subsection{Noise Generator}

\begin{description}

\rwreg{noise/arm}  A 0 to 1 transition of bit~0 arms the digital noise
generator to re-seed on the next internal 1~PPS pulse.  This can be used to
synchronously seed noise generators across multiple devices or within one
device.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize arm}}
\end{bytefield}

\rwreg{noise/seed} Sets the 32~bit seed for the digital noise generator.
Because the inputs are demultiplexed by 4, the digital noise generator actually
contains two noise generators that each output two independent normally
distributed values each.  The 32~bit seed is actually split into two 16~bits
seeds to seed the two contained noise generators.  Using a seed whose two
halves are identical (i.e.\ a multiple of 65537) will result in a signal that
has a lag-2 correlation coefficient of 1 resulting in a non-flat spectrum.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{16}{seed high} &
  \bitbox{16}{seed low}
\end{bytefield}

\end{description}

  \subsection{Delay Core}

The Delay Core delays the comparison input signal and converts it from real to
complex representation.  The delay can range from $0$ to $8191\frac{15}{16}$
samples in increments of $\frac{1}{16}$ of a sample.  The delay is implemented
as a combination of coarse delay (in units of FPGA clock cycles), fine delay
(in units of ADC sample clock cycles), and sub-sample delay (in units of
$\frac{1}{16}$ an ADC sample clock cycle).  The sub-sample delay is implemented
using a quadrature fractional delay FIR filter that not only does sub sample
delay, but also the conversion to complex form.  Converting to complex form
involves mixing by a local oscillator at $\pm F_s/4$.  The sign of the LO
frequency is user selectable and determines whether the Delay Core's complex
output will consist of the positive or negative frequencies of the real input.
Selecting the negative frequencies will result in a frequency reversal and
conjugation relative the positive frequencies.  See the \verb|sbsel| register
for more details.

\begin{description}

\rwreg{delay0} The 17 \LSbs of this register specify the delay to be
applied to the comparison input by the Delay Core.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{15}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{17}{delay}
\end{bytefield}

\filbreak
The value written into these registers can be computed as

\begin{align*}
register\_value &= 16 \cdot adc\_sample\_delay + 64 &(\mathrm{mod}\:2^{17}) \\
                &= \mathrm{round}(16.384 \cdot ns\_delay) + 64 &(\mathrm{mod}\:2^{17})
\end{align*}

For example, to obtain a delay of 123.456~ns, the value to use would be
computed as

\begin{align*}
register\_value &= \mathrm{round}(16.384 \cdot 123.456) + 64 &(\mathrm{mod}\:2^{17}) \\
                &= 2087
\end{align*}

Because of the 64 sample offset and modulo $2^{17}$ behavior, minimum delay is
obtained with a value of 64, while maximum delay is obtained with a value of
63.

\rwreg{sbsel} The \verb|sbsel| (sideband select) register specifies whether the
complex output will consist of the positive or negative frequencies of the real
input.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize sel}}
\end{bytefield}

A value of 0 selects the positive frequencies; a value of 1 selects the
negative frequencies.

\end{description}

  \subsection{Phase Offset and Fringe Tracking}

The comparison input can have a constant phase offset and variable pahse offset
(i.e. fringe tracking) applied.

\begin{description}

\rwreg{phase0} This register specifies the amount of user-specified "constant"
(i.e. rarely changing) phase rotation to be applied to the comparison input's
complex signal.  The overall phase offset that is applied may optionally
include an additional time-varying phase offset from the fringe tracking logic.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{20}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{12}{phase}
\end{bytefield}

Because only the 12 least significant bits of these registers are used for one
complete turn in phase, the resolution is $\frac{2 \pi}{2^{12}}$ radians per
step or $\frac{360}{2^{12}}$ degrees per step (i.e. approximately 88
millidegrees per step).

\filbreak
\rwreg{fringe\_rate} This register specifies the fringe rate that is to be
applied to the comparison input (in addition to the phase offset).  The \MSb is
the sign of the fringe rate.  The 12 \LSbs specify the fringe rate.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{1}{\rotatebox{90}{\scriptsize sign}}
  \bitbox{19}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{12}{rate}
\end{bytefield}

TODO: What is the unit of rate?

\end{description}

  \subsection{Single Baseline Correlator}

\begin{description}

\rwregn{quant/thresh0}
\rwregs{quant/thresh1}  These registers set the thresholding level used for
quantizing the inputs to the single baseline correlator.  The first input's
threshold is given by \verb|quant/thresh0|; the second input's by
\verb|quant/thresh1|.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{25}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{7}{threshold}
\end{bytefield}

For more details. see the $\mathtt{quant/thresh}N$ registers in the iBob Phased
Array section.

\rwreg{corr/syncsel} This register selects the sync signal used to drive integration
timing.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{\scriptsize sel}
\end{bytefield}

The sync signal selection determines the units of the \verb|integ_time|
register.  The four choices are:

\begin{description}
\item[0] Use the 1024~PPS signal to define the integration units.
\item[1] Use the HB signal to define the integration units.
\item[2] Use the SOWF signal to define the integration units.
\item[3] Use the 1~PPS signal to define the integration units.
\end{description}

\rwreg{corr/integ\_time} This register sets the integration time in units of
the sync signal selected via the \verb|syncsel| register.  Changing the value
of this register resets the correlator's internals as well as the
\verb|integ_cnt| register.

\roreg{corr/integ\_cnt} This register simply counts the number of integrations
that have completed.  When this register increments, a new integration is ready
to be read.  Changing the \verb|integ_time| register resets this register.

\roreg{corr/sample\_cnt} The correlator always integrates in multiples of 32
samples (since there are 16 lags per baseline and 2 samples per FPGA clock
cycle).  If the selected integration unit (see \verb|syncsel|) is not
commensurate with 32 samples (e.g. the Heartbeat signal) then the number of
samples per integration can vary from integration to integration.  This
register provides the number of 32-sample sub-integrations in the most recently
completed integration.  It can be used to properly average the data.  Since the
integrated values are pre-divided by 32 in the FPGA, the output values can be
divided by this register value directly to get the average of the integrated
products.

\roreg{corr/subint\_cnt} This register indicates how far along the current
integration is.  It is in units of the sync signal selected via the
\verb|syncsel| register.  It counts from 0 to $integ\_time - 1$, then starts
over.

\bramn{corr/real}
\brams{corr/imag} These shared BRAMs hold the integrated 16~lag spectrum for
the single baseline correlator.  The \verb|corr/real| BRAM contains the
integrated real component.  The \verb|corr/imag_imag| BRAM contains the
integrated imaginary component.  The 16 lags are stored from lag~-8 to lag~+7.

\end{description}

  \subsection{Snapshot Data}

The DBE design includes a snapshot block that can be used to capture some input
samples to help set the threshold registers and other diagnostic purposes.  The
input to the snap block is the same as the input to the single baseline
correlator (see the \verb|corrsel0| register).

\begin{description}

\rwreg{snap/ctrl} This register controls the snapshot block.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{\rotatebox{90}{\scriptsize trg}} &&
  \bitbox{1}{\rotatebox{90}{\scriptsize en}}
\end{bytefield}

A 0 to 1 transition of bit~0 (en) enables a snapshot sequence.  Once the
snapshot sequence is enabled, the data capture will begin immediately if bit~1
(trg) is 1 or on the next selected sync pulse (see \verb|syncsel|) if bit~1
(trg) is 0.

\filbreak
\roreg{snap/addr} During data capture, this register provides the address
within the shared BRAMs to which the data are being written.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{21}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{11}{snap address}
\end{bytefield}

When the data capture is complete, the address holds at the final value of
2047.  The data capture completes in 8~\textmu s, so this register is useful
primarily when the data capture is setup to begin on the next sync pulse
(otherwise it is unlikely that any value other than 2047 will be observed in
this register).

\bram{snap/bram} This shared BRAMs hold the snapshot data.  Each BRAM is 2048
words deep.  Within the BRAM, each 32~bit word stores two complex samples for
the selected input.  The \MSB holds the real component of the first complex
sample; the \LSB holds the imaginary component of the second complex sample.
Thus, the shared BRAM can hold 4096 complex samples for the selected input.
The storage format for the first word (BRAM address 0) of \verb|snap/bram| is
shown in the following diagram.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{8}{re0} &
  \bitbox{8}{im0} &
  \bitbox{8}{re1} &
  \bitbox{8}{im1}
\end{bytefield}

\end{description}

  \subsection{VSI Formatting}

\begin{description}

\rwreg{outsel} This register has something to do with the formatting of the
data for the data recorder.  It is initialized to 3 at FPGA startup.
\textbf{Do not change this register!}

\bramn{pol0/gainctrl0}
\brams{pol0/gainctrl1} These Block RAMs control the 2-bit quantization of the
data being sent to the data recorder.  The first 8 locations are initialized
to 200 at FPGA startup.  The data recorder have software that analyzes the
histogram of the 2-bit data to compute new values to optimize the quantization.

\rwreg{pol0/gainreset} This register has something to do with the
$\mathtt{pol0/gainctrl}N$ Block RAMs, but I'm not sure of the exact purpose.

\rwreg{shiftctrl\_reg}  This register controls the shifting within the PFB that
channelizes the data before sending it to the data recorder.  It is
initialized to \verb|0xffffffff| (i.e. shift every stage) at FGPA startup.

\end{description}

\filbreak
  \subsection{Front Panel SMA Output}

\begin{description}

\rwreg{sma1pps\_sel} Selects which signal to output over the front panel
\verb|SMA1| (lower) connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{30}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{2}{sel}
\end{bytefield}

\begin{description}

\item[0] Outputs the sampled 1~PPS signal (from ADC0)

\item[1] Outputs the internal 1~PPS signal.

\item[2] Outputs the internal 1024~PPS signal.

\end{description}

\rwreg{smavsisel} Selects which signal to output over the front panel
\verb|SMA0| (upper) connector.

\vspace{2\parskip}
\begin{bytefield}{32}
  \bitheader[b]{0-31} \\
  \bitbox{31}{\color[gray]{0.75}\rule{\width}{\height}} &
  \bitbox{1}{sel}
\end{bytefield}

\begin{description}

\item[0] Outputs the 64~MHz clock being sent over VSI to the data recorder.

\item[1] Outputs the 1~PPS signal being sent over VSI to the data recorder.

\end{description}


\end{description}

  \subsection{Front Panel LEDs}

The DBE design does not use any of the front panel LEDs.

\verb|LED8| indicates that the FPGA is configured (non-functional on some iBobs).

\end{document}
